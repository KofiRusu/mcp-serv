"""
Thought Engine - Core Processing System for ChatOS Thought-Line Protocol

This module implements the thought-line processing pipeline where each "thought"
(decision hypothesis) traverses multiple processing layers and filters.

A thought represents a single decision hypothesis that must:
1. Gather live market context
2. Build historical contexts A/B/C
3. Pass through Filter A (Orderflow)
4. Pass through Filter B (Regime)
5. Pass through Filter C (Performance)
6. Generate a trading decision if all filters pass

The engine supports:
- Parallel thought execution
- Full trace recording for audit/replay
- EventBus integration for status broadcasting
- Deterministic processing with stored context snapshots
"""

import asyncio
import logging
import time
import uuid
from dataclasses import dataclass, field
from datetime import datetime, timedelta, timezone
from enum import Enum
from typing import Any, Callable, Dict, List, Optional, Tuple

from chatos_backend.core.event_bus import get_event_bus, EventPriority
from chatos_backend.services.historical_context import (
    ContextA, ContextB, ContextC,
    get_context_builder
)

logger = logging.getLogger(__name__)


class ThoughtStatus(str, Enum):
    PENDING = "pending"
    RUNNING = "running"
    GATHERING_CONTEXT = "gathering_context"
    FILTERING = "filtering"
    GENERATING_DECISION = "generating_decision"
    PASSED = "passed"
    WARNED = "warned"
    BLOCKED = "blocked"
    FAILED = "failed"
    TIMEOUT = "timeout"


class FilterStatus(str, Enum):
    PASS = "pass"
    WARN = "warn"
    BLOCK = "block"


class TradingSignal(str, Enum):
    LONG = "LONG"
    SHORT = "SHORT"
    CLOSE = "CLOSE"
    HOLD = "HOLD"


@dataclass
class FilterSpec:
    """Specification for a filter in the thought pipeline."""
    name: str
    filter_type: str
    enabled: bool = True
    config: Dict[str, Any] = field(default_factory=dict)


@dataclass
class FilterResult:
    """Result of applying a filter to a thought."""
    filter_name: str
    filter_type: str
    status: FilterStatus
    score: float = 0.0
    reason: str = ""
    details: Dict[str, Any] = field(default_factory=dict)
    execution_time_ms: float = 0.0
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "filter_name": self.filter_name,
            "filter_type": self.filter_type,
            "status": self.status.value,
            "score": self.score,
            "reason": self.reason,
            "details": self.details,
            "execution_time_ms": self.execution_time_ms,
        }


@dataclass
class TradingDecision:
    """A trading decision generated by a thought."""
    signal: TradingSignal
    symbol: str
    confidence: float = 0.5
    entry_price: Optional[float] = None
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    position_size: Optional[float] = None
    leverage: float = 1.0
    reasoning: str = ""
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "signal": self.signal.value,
            "symbol": self.symbol,
            "confidence": self.confidence,
            "entry_price": self.entry_price,
            "stop_loss": self.stop_loss,
            "take_profit": self.take_profit,
            "position_size": self.position_size,
            "leverage": self.leverage,
            "reasoning": self.reasoning,
        }


@dataclass
class TraceStep:
    """A single step in the thought execution trace."""
    step_name: str
    timestamp: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    duration_ms: float = 0.0
    data: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "step_name": self.step_name,
            "timestamp": self.timestamp.isoformat(),
            "duration_ms": self.duration_ms,
            "data": self.data,
        }


@dataclass
class ThoughtSpec:
    """Specification for a single thought (decision hypothesis)."""
    id: str = field(default_factory=lambda: str(uuid.uuid4())[:12])
    name: str = "default_thought"
    symbol: str = "BTCUSDT"
    hypothesis: str = ""
    required_contexts: List[str] = field(default_factory=lambda: ["A", "B", "C"])
    filters: List[FilterSpec] = field(default_factory=list)
    model: str = "persrm"
    timeout_ms: int = 30000
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "name": self.name,
            "symbol": self.symbol,
            "hypothesis": self.hypothesis,
            "required_contexts": self.required_contexts,
            "filters": [{"name": f.name, "type": f.filter_type, "enabled": f.enabled} for f in self.filters],
            "model": self.model,
            "timeout_ms": self.timeout_ms,
        }


@dataclass
class ThoughtRun:
    """Execution trace of a single thought through the pipeline."""
    spec: ThoughtSpec
    id: str = field(default_factory=lambda: str(uuid.uuid4())[:12])
    started_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    completed_at: Optional[datetime] = None
    status: ThoughtStatus = ThoughtStatus.PENDING
    
    live_context: Dict[str, Any] = field(default_factory=dict)
    context_a: Optional[ContextA] = None
    context_b: Optional[ContextB] = None
    context_c: Optional[ContextC] = None
    
    filter_results: List[FilterResult] = field(default_factory=list)
    
    decision: Optional[TradingDecision] = None
    
    trace: List[TraceStep] = field(default_factory=list)
    error: Optional[str] = None
    
    def add_trace(self, step_name: str, data: Dict[str, Any] = None, duration_ms: float = 0.0):
        self.trace.append(TraceStep(
            step_name=step_name,
            data=data or {},
            duration_ms=duration_ms,
        ))
    
    def get_duration_ms(self) -> float:
        if self.completed_at:
            return (self.completed_at - self.started_at).total_seconds() * 1000
        return (datetime.now(timezone.utc) - self.started_at).total_seconds() * 1000
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "spec": self.spec.to_dict(),
            "started_at": self.started_at.isoformat(),
            "completed_at": self.completed_at.isoformat() if self.completed_at else None,
            "status": self.status.value,
            "duration_ms": self.get_duration_ms(),
            "live_context": self.live_context,
            "context_a_hash": self.context_a.get_hash() if self.context_a else None,
            "context_b_hash": self.context_b.get_hash() if self.context_b else None,
            "context_c_hash": self.context_c.get_hash() if self.context_c else None,
            "filter_results": [f.to_dict() for f in self.filter_results],
            "decision": self.decision.to_dict() if self.decision else None,
            "trace": [t.to_dict() for t in self.trace],
            "error": self.error,
        }


class ThoughtFilter:
    """Base class for thought filters."""
    
    name: str = "base_filter"
    filter_type: str = "base"
    
    async def apply(
        self,
        thought: ThoughtRun,
        context_a: Optional[ContextA] = None,
        context_b: Optional[ContextB] = None,
        context_c: Optional[ContextC] = None,
    ) -> FilterResult:
        raise NotImplementedError


class FilterA_Orderflow(ThoughtFilter):
    """Filter based on Market Microstructure + Orderflow."""
    
    name = "orderflow_filter"
    filter_type = "A"
    
    def __init__(self, config: Dict[str, Any] = None):
        self.config = config or {}
        self.cvd_threshold = self.config.get("cvd_threshold", 0.3)
        self.whale_imbalance_threshold = self.config.get("whale_imbalance_threshold", 0.6)
        self.liquidation_cascade_threshold = self.config.get("liquidation_cascade_threshold", 1000000)
        self.funding_extreme_threshold = self.config.get("funding_extreme_threshold", 0.05)
    
    async def apply(
        self,
        thought: ThoughtRun,
        context_a: Optional[ContextA] = None,
        **kwargs
    ) -> FilterResult:
        start = time.time()
        
        if not context_a:
            return FilterResult(
                filter_name=self.name,
                filter_type=self.filter_type,
                status=FilterStatus.WARN,
                score=0.5,
                reason="Context A not available",
                execution_time_ms=(time.time() - start) * 1000,
            )
        
        issues = []
        warnings = []
        score = 1.0
        
        whale_total = context_a.whale_buy_pressure + context_a.whale_sell_pressure
        if whale_total > 0:
            whale_imbalance = abs(context_a.whale_buy_pressure - context_a.whale_sell_pressure) / whale_total
            if whale_imbalance > self.whale_imbalance_threshold:
                dominant = "buy" if context_a.whale_buy_pressure > context_a.whale_sell_pressure else "sell"
                warnings.append(f"High whale {dominant} pressure ({whale_imbalance:.1%})")
                score -= 0.1
        
        total_liqs = context_a.liquidations_1h.get("total", 0)
        if total_liqs > self.liquidation_cascade_threshold:
            issues.append(f"Liquidation cascade risk: ${total_liqs/1e6:.1f}M in 1h")
            score -= 0.3
        
        if abs(context_a.funding_rate) > self.funding_extreme_threshold:
            direction = "long" if context_a.funding_rate > 0 else "short"
            issues.append(f"Extreme funding rate ({context_a.funding_rate:.3%}): crowded {direction}s")
            score -= 0.2
        
        if context_a.oi_price_divergence:
            warnings.append("OI-Price divergence detected")
            score -= 0.15
        
        if issues:
            status = FilterStatus.BLOCK
            reason = "; ".join(issues)
        elif warnings:
            status = FilterStatus.WARN
            reason = "; ".join(warnings)
        else:
            status = FilterStatus.PASS
            reason = "Orderflow conditions favorable"
        
        return FilterResult(
            filter_name=self.name,
            filter_type=self.filter_type,
            status=status,
            score=max(0, min(1, score)),
            reason=reason,
            details={
                "cvd_trend": context_a.cvd_trend,
                "whale_buy": context_a.whale_buy_pressure,
                "whale_sell": context_a.whale_sell_pressure,
                "funding_rate": context_a.funding_rate,
                "liquidations_1h": context_a.liquidations_1h,
                "oi_divergence": context_a.oi_price_divergence,
            },
            execution_time_ms=(time.time() - start) * 1000,
        )


class FilterB_Regime(ThoughtFilter):
    """Filter based on Regime + Volatility."""
    
    name = "regime_filter"
    filter_type = "B"
    
    def __init__(self, config: Dict[str, Any] = None):
        self.config = config or {}
        self.vol_extreme_threshold = self.config.get("vol_extreme_threshold", 90)
        self.drawdown_threshold = self.config.get("drawdown_threshold", 10)
        self.correlation_breakdown_threshold = self.config.get("correlation_breakdown_threshold", 0.3)
    
    async def apply(
        self,
        thought: ThoughtRun,
        context_b: Optional[ContextB] = None,
        **kwargs
    ) -> FilterResult:
        start = time.time()
        
        if not context_b:
            return FilterResult(
                filter_name=self.name,
                filter_type=self.filter_type,
                status=FilterStatus.WARN,
                score=0.5,
                reason="Context B not available",
                execution_time_ms=(time.time() - start) * 1000,
            )
        
        issues = []
        warnings = []
        score = 1.0
        
        if context_b.vol_percentile > self.vol_extreme_threshold:
            issues.append(f"Extreme volatility regime ({context_b.vol_percentile:.0f}th percentile)")
            score -= 0.3
        elif context_b.vol_regime == "high":
            warnings.append("High volatility conditions")
            score -= 0.1
        
        if context_b.max_drawdown_24h > self.drawdown_threshold:
            issues.append(f"Significant drawdown: {context_b.max_drawdown_24h:.1f}% in 24h")
            score -= 0.2
        
        if context_b.correlation_breakdown:
            warnings.append("Correlation breakdown detected")
            score -= 0.15
        
        if context_b.current_regime == "volatile_breakout":
            warnings.append("Volatile breakout regime - increased uncertainty")
            score -= 0.1
        
        if context_b.regime_confidence < 0.4:
            warnings.append(f"Low regime confidence ({context_b.regime_confidence:.0%})")
            score -= 0.1
        
        if issues:
            status = FilterStatus.BLOCK
            reason = "; ".join(issues)
        elif warnings:
            status = FilterStatus.WARN
            reason = "; ".join(warnings)
        else:
            status = FilterStatus.PASS
            reason = f"Regime favorable ({context_b.current_regime})"
        
        return FilterResult(
            filter_name=self.name,
            filter_type=self.filter_type,
            status=status,
            score=max(0, min(1, score)),
            reason=reason,
            details={
                "regime": context_b.current_regime,
                "regime_confidence": context_b.regime_confidence,
                "vol_regime": context_b.vol_regime,
                "vol_percentile": context_b.vol_percentile,
                "drawdown_24h": context_b.max_drawdown_24h,
                "correlation_btc": context_b.correlation_btc,
            },
            execution_time_ms=(time.time() - start) * 1000,
        )


class FilterC_Performance(ThoughtFilter):
    """Filter based on Strategy + Agent Performance."""
    
    name = "performance_filter"
    filter_type = "C"
    
    def __init__(self, config: Dict[str, Any] = None):
        self.config = config or {}
        self.min_win_rate = self.config.get("min_win_rate", 0.4)
        self.max_calibration_error = self.config.get("max_calibration_error", 0.2)
        self.max_recent_breaches = self.config.get("max_recent_breaches", 3)
        self.max_slippage_bps = self.config.get("max_slippage_bps", 50)
    
    async def apply(
        self,
        thought: ThoughtRun,
        context_c: Optional[ContextC] = None,
        **kwargs
    ) -> FilterResult:
        start = time.time()
        
        if not context_c:
            return FilterResult(
                filter_name=self.name,
                filter_type=self.filter_type,
                status=FilterStatus.WARN,
                score=0.5,
                reason="Context C not available",
                execution_time_ms=(time.time() - start) * 1000,
            )
        
        issues = []
        warnings = []
        score = 1.0
        
        if context_c.total_trades >= 10 and context_c.win_rate < self.min_win_rate:
            warnings.append(f"Low win rate: {context_c.win_rate:.0%}")
            score -= 0.2
        
        if context_c.calibration_error > self.max_calibration_error:
            warnings.append(f"Model miscalibrated: {context_c.calibration_error:.1%} error")
            score -= 0.15
        
        if context_c.breach_count_7d > self.max_recent_breaches:
            issues.append(f"Multiple risk breaches: {context_c.breach_count_7d} in 7 days")
            score -= 0.3
        
        if context_c.recent_kill_switch:
            issues.append("Recent kill switch triggered")
            score -= 0.4
        
        if context_c.avg_slippage_bps > self.max_slippage_bps:
            warnings.append(f"High slippage: {context_c.avg_slippage_bps:.0f} bps avg")
            score -= 0.1
        
        if context_c.latency_issues:
            warnings.append("Latency issues detected")
            score -= 0.1
        
        if context_c.overconfident:
            warnings.append("Model appears overconfident")
            score -= 0.1
        
        if issues:
            status = FilterStatus.BLOCK
            reason = "; ".join(issues)
        elif warnings:
            status = FilterStatus.WARN
            reason = "; ".join(warnings)
        else:
            status = FilterStatus.PASS
            reason = "Performance metrics acceptable"
        
        return FilterResult(
            filter_name=self.name,
            filter_type=self.filter_type,
            status=status,
            score=max(0, min(1, score)),
            reason=reason,
            details={
                "win_rate": context_c.win_rate,
                "total_trades": context_c.total_trades,
                "calibration_error": context_c.calibration_error,
                "breach_count_7d": context_c.breach_count_7d,
                "avg_slippage_bps": context_c.avg_slippage_bps,
                "daily_pnl": context_c.daily_pnl_usd,
            },
            execution_time_ms=(time.time() - start) * 1000,
        )


class ThoughtEngine:
    """
    Core engine for executing thoughts through the processing pipeline.
    
    Responsibilities:
    - Execute thoughts with context gathering and filtering
    - Generate trading decisions via model inference
    - Record full traces for audit/replay
    - Broadcast status updates via EventBus
    """
    
    def __init__(self):
        self._context_builder = None
        self._event_bus = None
        self._store = None
        self._trading_brain = None
        self.active_thoughts: Dict[str, ThoughtRun] = {}
        
        self.default_filters = [
            FilterA_Orderflow(),
            FilterB_Regime(),
            FilterC_Performance(),
        ]
    
    @property
    def context_builder(self):
        if self._context_builder is None:
            self._context_builder = get_context_builder()
        return self._context_builder
    
    @property
    def event_bus(self):
        if self._event_bus is None:
            self._event_bus = get_event_bus()
        return self._event_bus
    
    @property
    def store(self):
        if self._store is None:
            from chatos_backend.services.realtime_data_store import get_realtime_store
            self._store = get_realtime_store()
        return self._store
    
    @property
    def trading_brain(self):
        if self._trading_brain is None:
            try:
                from chatos_backend.services.trading_brain import TradingBrain
                self._trading_brain = TradingBrain()
            except ImportError:
                logger.warning("TradingBrain not available")
                self._trading_brain = None
        return self._trading_brain
    
    async def run_thought(self, spec: ThoughtSpec) -> ThoughtRun:
        """Execute a single thought through the complete pipeline."""
        run = ThoughtRun(spec=spec)
        self.active_thoughts[run.id] = run
        
        try:
            run.status = ThoughtStatus.RUNNING
            await self._publish_status(run, "started")
            
            run.status = ThoughtStatus.GATHERING_CONTEXT
            await self._gather_contexts(run)
            
            run.status = ThoughtStatus.FILTERING
            blocked = await self._apply_filters(run)
            
            if blocked:
                run.status = ThoughtStatus.BLOCKED
                run.completed_at = datetime.now(timezone.utc)
                await self._publish_status(run, "blocked")
                return run
            
            run.status = ThoughtStatus.GENERATING_DECISION
            await self._generate_decision(run)
            
            has_warnings = any(f.status == FilterStatus.WARN for f in run.filter_results)
            run.status = ThoughtStatus.WARNED if has_warnings else ThoughtStatus.PASSED
            run.completed_at = datetime.now(timezone.utc)
            
            await self._publish_status(run, "completed")
            
        except asyncio.TimeoutError:
            run.status = ThoughtStatus.TIMEOUT
            run.error = f"Timeout after {spec.timeout_ms}ms"
            run.completed_at = datetime.now(timezone.utc)
            await self._publish_status(run, "timeout")
            
        except Exception as e:
            run.status = ThoughtStatus.FAILED
            run.error = str(e)
            run.completed_at = datetime.now(timezone.utc)
            logger.error(f"Thought {run.id} failed: {e}")
            await self._publish_status(run, "failed")
        
        finally:
            if run.id in self.active_thoughts:
                del self.active_thoughts[run.id]
        
        return run
    
    async def _gather_contexts(self, run: ThoughtRun):
        """Gather all required contexts for the thought."""
        start = time.time()
        
        ticker = self.store.get_ticker(run.spec.symbol)
        if ticker:
            run.live_context = {
                "symbol": run.spec.symbol,
                "price": ticker.price,
                "change_24h": ticker.change_24h,
                "volume_24h": ticker.volume_24h,
                "timestamp": ticker.timestamp,
            }
        else:
            run.live_context = {"symbol": run.spec.symbol, "price": 0, "change_24h": 0}
        
        run.add_trace("live_context", run.live_context, (time.time() - start) * 1000)
        
        context_start = time.time()
        
        tasks = []
        if "A" in run.spec.required_contexts:
            tasks.append(("A", self.context_builder.build_context_a(run.spec.symbol)))
        if "B" in run.spec.required_contexts:
            tasks.append(("B", self.context_builder.build_context_b(run.spec.symbol)))
        if "C" in run.spec.required_contexts:
            tasks.append(("C", self.context_builder.build_context_c(run.spec.symbol)))
        
        if tasks:
            results = await asyncio.gather(*[t[1] for t in tasks], return_exceptions=True)
            
            for (ctx_type, _), result in zip(tasks, results):
                if isinstance(result, Exception):
                    logger.warning(f"Failed to build context {ctx_type}: {result}")
                    continue
                
                if ctx_type == "A":
                    run.context_a = result
                elif ctx_type == "B":
                    run.context_b = result
                elif ctx_type == "C":
                    run.context_c = result
        
        run.add_trace("contexts_built", {
            "context_a": run.context_a is not None,
            "context_b": run.context_b is not None,
            "context_c": run.context_c is not None,
        }, (time.time() - context_start) * 1000)
    
    async def _apply_filters(self, run: ThoughtRun) -> bool:
        """Apply all filters to the thought. Returns True if blocked."""
        filters = self.default_filters
        
        for thought_filter in filters:
            start = time.time()
            
            result = await thought_filter.apply(
                run,
                context_a=run.context_a,
                context_b=run.context_b,
                context_c=run.context_c,
            )
            
            run.filter_results.append(result)
            run.add_trace(f"filter_{thought_filter.filter_type}", result.to_dict(), result.execution_time_ms)
            
            if result.status == FilterStatus.BLOCK:
                logger.info(f"Thought {run.id} blocked by {thought_filter.name}: {result.reason}")
                return True
        
        return False
    
    async def _generate_decision(self, run: ThoughtRun):
        """Generate a trading decision using the model."""
        start = time.time()
        
        if self.trading_brain and run.live_context.get("price", 0) > 0:
            try:
                brain_decision = await self.trading_brain.get_trading_decision(
                    symbol=run.spec.symbol,
                    price=run.live_context["price"],
                    change_24h=run.live_context.get("change_24h", 0),
                    existing_position=None,
                    balance=100000,
                    mode="paper",
                )
                
                signal_map = {
                    "LONG": TradingSignal.LONG,
                    "SHORT": TradingSignal.SHORT,
                    "CLOSE": TradingSignal.CLOSE,
                    "HOLD": TradingSignal.HOLD,
                }
                
                run.decision = TradingDecision(
                    signal=signal_map.get(brain_decision.get("signal", "HOLD"), TradingSignal.HOLD),
                    symbol=run.spec.symbol,
                    confidence=brain_decision.get("confidence", 0.5),
                    entry_price=run.live_context["price"],
                    stop_loss=brain_decision.get("stop_loss"),
                    take_profit=brain_decision.get("take_profit"),
                    reasoning=brain_decision.get("reasoning", ""),
                )
                
            except Exception as e:
                logger.warning(f"Trading brain decision failed: {e}")
                run.decision = self._fallback_decision(run)
        else:
            run.decision = self._fallback_decision(run)
        
        run.add_trace("decision_generated", run.decision.to_dict() if run.decision else {}, (time.time() - start) * 1000)
    
    def _fallback_decision(self, run: ThoughtRun) -> TradingDecision:
        """Generate a fallback HOLD decision."""
        return TradingDecision(
            signal=TradingSignal.HOLD,
            symbol=run.spec.symbol,
            confidence=0.3,
            reasoning="Fallback decision - insufficient data for signal generation",
        )
    
    async def _publish_status(self, run: ThoughtRun, event_suffix: str):
        """Publish thought status to EventBus."""
        await self.event_bus.publish(
            f"thought.{event_suffix}",
            {
                "thought_id": run.id,
                "spec_id": run.spec.id,
                "symbol": run.spec.symbol,
                "status": run.status.value,
                "duration_ms": run.get_duration_ms(),
                "decision": run.decision.to_dict() if run.decision else None,
            },
            source="thought_engine"
        )
    
    async def run_parallel_thoughts(self, specs: List[ThoughtSpec]) -> List[ThoughtRun]:
        """Run multiple thoughts in parallel."""
        return await asyncio.gather(*[self.run_thought(spec) for spec in specs])
    
    def create_default_specs(self, symbol: str) -> List[ThoughtSpec]:
        """Create default thought specs for a symbol."""
        return [
            ThoughtSpec(
                name="trend_following",
                symbol=symbol,
                hypothesis=f"Price trend continuation for {symbol}",
            ),
            ThoughtSpec(
                name="mean_reversion",
                symbol=symbol,
                hypothesis=f"Price mean reversion opportunity for {symbol}",
            ),
            ThoughtSpec(
                name="momentum",
                symbol=symbol,
                hypothesis=f"Momentum breakout for {symbol}",
            ),
        ]


_thought_engine: Optional[ThoughtEngine] = None


def get_thought_engine() -> ThoughtEngine:
    """Get the thought engine singleton."""
    global _thought_engine
    if _thought_engine is None:
        _thought_engine = ThoughtEngine()
    return _thought_engine
