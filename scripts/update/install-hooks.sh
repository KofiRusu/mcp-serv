#!/bin/bash
# =============================================================================
# ChatOS v2.0 - Git Hooks Installer
# =============================================================================
# Installs opt-in git hooks that automatically run the cross-OS update
# pipeline when code is pulled/merged.
#
# Hooks installed:
#   - post-merge: Runs after git pull/merge
#   - post-checkout: Runs after git checkout (branch switch)
#
# Usage:
#   ./install-hooks.sh             # Install hooks
#   ./install-hooks.sh --uninstall # Remove hooks
#   ./install-hooks.sh --status    # Check hook status
#
# =============================================================================

set -e

# =============================================================================
# Configuration
# =============================================================================

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"
GIT_HOOKS_DIR="$REPO_ROOT/.git/hooks"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

# =============================================================================
# Functions
# =============================================================================

log_info() {
    echo -e "${BLUE}[HOOKS]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[HOOKS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[HOOKS]${NC} $1"
}

log_error() {
    echo -e "${RED}[HOOKS]${NC} $1"
}

print_banner() {
    echo -e "${CYAN}"
    echo "╔══════════════════════════════════════════════════════════════════╗"
    echo "║         ChatOS v2.0 - Git Hooks Installer                        ║"
    echo "║              Automated Cross-OS Update Pipeline                  ║"
    echo "╚══════════════════════════════════════════════════════════════════╝"
    echo -e "${NC}"
}

show_help() {
    cat << EOF
ChatOS v2.0 - Git Hooks Installer

USAGE:
    ./install-hooks.sh [OPTIONS]

OPTIONS:
    --install       Install git hooks (default)
    --uninstall     Remove git hooks
    --status        Check current hook status
    --help, -h      Show this help message

DESCRIPTION:
    This script installs git hooks that automatically run the cross-OS
    update pipeline after git operations like pull and merge.

    Hooks are OPT-IN: they won't be installed unless you explicitly run
    this script.

INSTALLED HOOKS:
    post-merge      Runs after 'git pull' or 'git merge'
    post-checkout   Runs after 'git checkout' (branch switch)

WHAT THE HOOKS DO:
    1. Detect if the OS has changed since last update
    2. If changed, run translation transforms
    3. Optionally run verification (can be skipped via env var)

ENVIRONMENT VARIABLES:
    CHATOS_SKIP_HOOK_VERIFY=1    Skip verification phase in hooks
    CHATOS_HOOK_VERBOSE=1        Enable verbose output in hooks

EOF
}

# Generate hook content
generate_hook_content() {
    local hook_type="$1"
    
    cat << 'HOOKEOF'
#!/bin/bash
# =============================================================================
# ChatOS v2.0 - Auto-generated Git Hook (Fast & Smart)
# Generated by: scripts/update/install-hooks.sh
# =============================================================================

# Don't exit on error - hooks should be resilient
set +e

# Get repo root
REPO_ROOT="$(git rev-parse --show-toplevel 2>/dev/null)"
if [ -z "$REPO_ROOT" ]; then
    exit 0  # Not in a git repo, skip silently
fi

# Check if autonomous mode is enabled
if [ ! -f "$REPO_ROOT/.git/chatos-auto-update" ]; then
    exit 0  # Autonomous mode disabled, skip silently
fi

# Skip if CHATOS_SKIP_HOOKS is set
if [ "${CHATOS_SKIP_HOOKS:-}" = "1" ]; then
    exit 0
fi

TRANSLATE_SCRIPT="$REPO_ROOT/scripts/update/translate_patch.sh"
UPDATE_SCRIPT="$REPO_ROOT/scripts/update/cross_os_update.sh"

# Check if scripts exist
if [ ! -f "$TRANSLATE_SCRIPT" ]; then
    exit 0  # Scripts not found, skip silently
fi

# Detect current OS
detect_os() {
    case "$(uname -s)" in
        Linux*)     echo "linux" ;;
        Darwin*)    echo "darwin" ;;
        *)          echo "unknown" ;;
    esac
}

CURRENT_OS=$(detect_os)
LAST_OS_FILE="$REPO_ROOT/.git/chatos-last-os"

# Quick mode: just run fast translation
run_quick_translate() {
    echo -e "\033[0;36m[ChatOS]\033[0m Running quick translation..."
    bash "$TRANSLATE_SCRIPT" 2>/dev/null
    echo -e "\033[0;32m[ChatOS]\033[0m ✓ Update complete"
}

# Full mode: run complete update with validation
run_full_update() {
    echo -e "\033[0;33m[ChatOS]\033[0m OS change detected ($LAST_OS → $CURRENT_OS)"
    echo -e "\033[0;36m[ChatOS]\033[0m Running full update..."
    
    if [ "${CHATOS_HOOK_FULL_VERIFY:-}" = "1" ]; then
        bash "$UPDATE_SCRIPT" 2>/dev/null
    else
        bash "$UPDATE_SCRIPT" --translate-only 2>/dev/null
    fi
    
    echo -e "\033[0;32m[ChatOS]\033[0m ✓ Full update complete"
}

# Main logic
if [ -f "$LAST_OS_FILE" ]; then
    LAST_OS=$(cat "$LAST_OS_FILE" 2>/dev/null)
    if [ "$CURRENT_OS" = "$LAST_OS" ]; then
        # Same OS - quick translation only
        run_quick_translate
    else
        # OS changed - full update
        run_full_update
    fi
else
    # First run - full update
    LAST_OS="(none)"
    run_full_update
fi

# Store current OS
echo "$CURRENT_OS" > "$LAST_OS_FILE" 2>/dev/null

exit 0
HOOKEOF
}

# Install a single hook
install_hook() {
    local hook_name="$1"
    local hook_path="$GIT_HOOKS_DIR/$hook_name"
    
    log_info "Installing $hook_name hook..."
    
    # Backup existing hook if present
    if [ -f "$hook_path" ]; then
        if grep -q "ChatOS" "$hook_path" 2>/dev/null; then
            log_info "ChatOS hook already installed, updating..."
        else
            local backup_path="${hook_path}.backup.$(date +%Y%m%d%H%M%S)"
            log_warning "Existing hook found, backing up to: $backup_path"
            mv "$hook_path" "$backup_path"
        fi
    fi
    
    # Generate and write hook
    generate_hook_content "$hook_name" > "$hook_path"
    chmod +x "$hook_path"
    
    log_success "Installed: $hook_path"
}

# Uninstall a single hook
uninstall_hook() {
    local hook_name="$1"
    local hook_path="$GIT_HOOKS_DIR/$hook_name"
    
    if [ -f "$hook_path" ]; then
        if grep -q "ChatOS" "$hook_path" 2>/dev/null; then
            rm "$hook_path"
            log_success "Removed: $hook_name"
            
            # Restore backup if exists
            local backup=$(ls -t "${hook_path}.backup."* 2>/dev/null | head -1)
            if [ -n "$backup" ]; then
                mv "$backup" "$hook_path"
                log_info "Restored backup: $backup"
            fi
        else
            log_warning "$hook_name is not a ChatOS hook, skipping"
        fi
    else
        log_info "$hook_name not installed"
    fi
}

# Check hook status
check_status() {
    log_info "Checking git hooks status..."
    echo ""
    
    local hooks=("post-merge" "post-checkout")
    
    for hook in "${hooks[@]}"; do
        local hook_path="$GIT_HOOKS_DIR/$hook"
        
        if [ -f "$hook_path" ]; then
            if grep -q "ChatOS" "$hook_path" 2>/dev/null; then
                echo -e "  ${GREEN}✓${NC} $hook: ChatOS hook installed"
            else
                echo -e "  ${YELLOW}○${NC} $hook: Custom hook (not ChatOS)"
            fi
        else
            echo -e "  ${RED}✗${NC} $hook: Not installed"
        fi
    done
    
    echo ""
    
    # Check last OS file
    local last_os_file="$REPO_ROOT/.git/chatos-last-os"
    if [ -f "$last_os_file" ]; then
        local last_os=$(cat "$last_os_file")
        echo -e "  Last known OS: ${CYAN}$last_os${NC}"
    else
        echo -e "  Last known OS: ${YELLOW}not recorded${NC}"
    fi
    
    echo ""
}

# Install all hooks
install_all() {
    print_banner
    
    log_info "Installing git hooks to: $GIT_HOOKS_DIR"
    
    # Ensure hooks directory exists
    mkdir -p "$GIT_HOOKS_DIR"
    
    # Install hooks
    install_hook "post-merge"
    install_hook "post-checkout"
    
    # Store current OS
    local current_os
    current_os=$(uname -s | tr '[:upper:]' '[:lower:]')
    case "$current_os" in
        linux)  current_os="linux" ;;
        darwin) current_os="darwin" ;;
    esac
    echo "$current_os" > "$REPO_ROOT/.git/chatos-last-os"
    
    echo ""
    log_success "Git hooks installed successfully!"
    echo ""
    echo -e "${CYAN}What happens now:${NC}"
    echo -e "  • After 'git pull' or 'git merge', translation runs automatically"
    echo -e "  • After switching branches, translation runs automatically"
    echo -e "  • Full verification only runs when OS changes"
    echo ""
    echo -e "${CYAN}To uninstall:${NC}"
    echo -e "  ./scripts/update/install-hooks.sh --uninstall"
    echo ""
}

# Uninstall all hooks
uninstall_all() {
    print_banner
    
    log_info "Removing git hooks..."
    
    uninstall_hook "post-merge"
    uninstall_hook "post-checkout"
    
    # Remove OS tracking file
    rm -f "$REPO_ROOT/.git/chatos-last-os"
    
    echo ""
    log_success "Git hooks removed successfully!"
    echo ""
}

# =============================================================================
# Main
# =============================================================================

main() {
    # Ensure we're in a git repository
    if [ ! -d "$REPO_ROOT/.git" ]; then
        log_error "Not a git repository"
        exit 1
    fi
    
    # Parse arguments
    local action="install"
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --install)
                action="install"
                shift
                ;;
            --uninstall)
                action="uninstall"
                shift
                ;;
            --status)
                action="status"
                shift
                ;;
            --help|-h)
                show_help
                exit 0
                ;;
            *)
                log_error "Unknown option: $1"
                echo "Use --help for usage information"
                exit 1
                ;;
        esac
    done
    
    # Execute action
    case "$action" in
        install)
            install_all
            ;;
        uninstall)
            uninstall_all
            ;;
        status)
            check_status
            ;;
    esac
}

# Run main
main "$@"

