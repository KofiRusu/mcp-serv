#!/usr/bin/env python3
"""
PersRM Trading Intelligence CLI
================================
Quick access to trading logs, stats, live views, and process management.
Cross-platform support for Linux and macOS.

Usage:
    trading start          - Start ALL trading processes
    trading stop           - Stop ALL trading processes
    trading restart        - Restart all processes
    
    # Individual process control:
    trading perpetual start/stop/restart/status
    trading hf start/stop/restart/status
    trading persrm start/stop/restart/status
    trading scraper start/stop/restart/status
    trading docker start/stop/status
    
    trading log            - View recent trading logs
    trading stats          - Show trading statistics
    trading view           - Live monitoring dashboard
    trading trades         - Recent trade history
    trading status         - System status
    trading help           - Show all commands
"""

import sys
import os
import json
import time
import platform
import subprocess
from datetime import datetime
from pathlib import Path

# Colors
class C:
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    END = '\033[0m'
    BOLD = '\033[1m'
    DIM = '\033[2m'

# Cross-platform configuration
IS_MAC = platform.system() == 'Darwin'
IS_LINUX = platform.system() == 'Linux'
HOME = Path.home()

# Platform-specific paths
if IS_MAC:
    TRADING_MEMORY = HOME / 'TradingMemory'
    PERSRM_DIR = HOME / 'persrm-distillation'
    CHATOS_DIR = HOME / 'ChatOS-v0.2'
    VENV_ACTIVATE = HOME / 'venv/bin/activate'
    WEBUI_VENV = HOME / 'venv/bin/activate'
    DATA_4TB = None
else:  # Linux
    TRADING_MEMORY = Path('/home/kr/TradingMemory')
    PERSRM_DIR = Path('/home/kr/persrm-distillation')
    CHATOS_DIR = Path('/home/kr/ChatOS-v0.2')
    VENV_ACTIVATE = Path('/home/kr/venv/bin/activate')
    WEBUI_VENV = Path('/home/kr/text-generation-webui/venv/bin/activate')
    DATA_4TB = Path('/mnt/data4tb/home/kr/persrm-data')

LOG_DIR = TRADING_MEMORY / 'logs'
TRADES_DIR = TRADING_MEMORY / 'trades'
HF_LOG_DIR = TRADING_MEMORY / 'logs/hf_trading'
PERSRM_LOG = CHATOS_DIR / 'models/persrm-continuous/training.log' if CHATOS_DIR.exists() else None


def print_header(title):
    """Print a styled header"""
    width = 60
    print(f"\n{C.CYAN}{'‚ïê' * width}{C.END}")
    print(f"{C.BOLD}{C.CYAN}  {title}{C.END}")
    print(f"{C.CYAN}{'‚ïê' * width}{C.END}\n")


def print_section(title):
    """Print a section header"""
    print(f"\n{C.YELLOW}‚ñ∂ {title}{C.END}")
    print(f"{C.DIM}{'‚îÄ' * 40}{C.END}")


def run_cmd(cmd, capture=True, shell=True):
    """Run a shell command"""
    try:
        result = subprocess.run(
            cmd, shell=shell, capture_output=capture, text=True
        )
        return result.stdout.strip() if capture else result.returncode == 0
    except Exception as e:
        return f"Error: {e}" if capture else False


def check_process(pattern):
    """Check if a process is running"""
    if IS_MAC:
        result = run_cmd(f"pgrep -f '{pattern}'")
    else:
        result = run_cmd(f"pgrep -af '{pattern}'")
    return bool(result and not result.startswith("Error"))


def kill_process(pattern):
    """Kill processes matching pattern"""
    run_cmd(f"pkill -f '{pattern}'", capture=False)


def ensure_dirs():
    """Ensure required directories exist"""
    LOG_DIR.mkdir(parents=True, exist_ok=True)
    TRADES_DIR.mkdir(parents=True, exist_ok=True)
    HF_LOG_DIR.mkdir(parents=True, exist_ok=True)


# =============================================================================
# ACCURATE STATE DETECTION
# =============================================================================

import re

def get_log_age_seconds(log_file):
    """Return seconds since log was last modified."""
    if not log_file or not Path(log_file).exists():
        return float('inf')
    try:
        mtime = Path(log_file).stat().st_mtime
        return time.time() - mtime
    except:
        return float('inf')


def format_time_ago(seconds):
    """Format seconds as human-readable time ago."""
    if seconds == float('inf'):
        return "never"
    if seconds < 60:
        return f"{int(seconds)}s ago"
    elif seconds < 3600:
        return f"{int(seconds / 60)}m ago"
    elif seconds < 86400:
        return f"{int(seconds / 3600)}h ago"
    else:
        return f"{int(seconds / 86400)}d ago"


def parse_persrm_progress(log_file):
    """
    Extract current epoch, total epochs, loss from PersRM log.
    Returns dict with: epoch, total_epochs, loss, step, state, details
    """
    result = {
        'epoch': None,
        'total_epochs': None,
        'loss': None,
        'step': None,
        'state': 'unknown',
        'details': '',
        'percent': 0,
    }
    
    if not log_file or not Path(log_file).exists():
        return result
    
    try:
        with open(log_file, 'r') as f:
            lines = f.readlines()
        
        # Read last 50 lines for efficiency
        recent_lines = lines[-50:] if len(lines) > 50 else lines
        text = ''.join(recent_lines)
        
        # Check for loading state - but only if we haven't started training yet
        has_epoch = bool(re.search(r'Epoch\s+\d+/\d+', text))
        
        if not has_epoch and ('Loading model' in text or 'Loading checkpoint' in text):
            # Find loading progress - get the LAST percentage (most recent)
            checkpoint_matches = re.findall(r'Loading checkpoint shards:\s*(\d+)%', text)
            if checkpoint_matches:
                pct = int(checkpoint_matches[-1])  # Get last match
                if pct < 100:
                    result['state'] = 'loading'
                    result['details'] = f"Loading model ({pct}%)"
                    return result
                else:
                    # 100% loaded but no epochs yet - still initializing
                    result['state'] = 'loading'
                    result['details'] = 'Initializing training...'
                    return result
            result['state'] = 'loading'
            result['details'] = 'Loading model...'
            return result
        
        # Check for errors
        error_patterns = ['Error:', 'Exception:', 'CUDA out of memory', 'RuntimeError', 'OOM']
        for pattern in error_patterns:
            if pattern in text:
                # Find the error line
                for line in reversed(recent_lines):
                    if pattern in line:
                        result['state'] = 'error'
                        result['details'] = line.strip()[:60]
                        return result
        
        # Parse epoch info - look for "Epoch X/Y" pattern
        epoch_matches = re.findall(r'Epoch\s+(\d+)/(\d+)', text)
        if epoch_matches:
            result['epoch'] = int(epoch_matches[-1][0])
            result['total_epochs'] = int(epoch_matches[-1][1])
            result['percent'] = (result['epoch'] / result['total_epochs'] * 100) if result['total_epochs'] > 0 else 0
        
        # Parse step and loss - look for "Step X: loss=Y" pattern
        step_matches = re.findall(r'Step\s+(\d+):\s+loss=([0-9.]+)', text)
        if step_matches:
            result['step'] = int(step_matches[-1][0])
            result['loss'] = float(step_matches[-1][1])
        
        # Determine state
        if result['epoch'] is not None:
            result['state'] = 'training'
            result['details'] = f"Epoch {result['epoch']}/{result['total_epochs']} ({result['percent']:.1f}%)"
            if result['loss'] is not None:
                result['details'] += f" | loss={result['loss']:.4f}"
        
        return result
        
    except Exception as e:
        result['state'] = 'error'
        result['details'] = f"Failed to parse log: {e}"
        return result


def get_process_state(process_name, pattern, log_file):
    """
    Get detailed process state by checking process existence and parsing logs.
    
    Returns: (state, details, color)
    States: 'stopped', 'loading', 'training', 'active', 'stalled', 'error'
    """
    STALE_THRESHOLD = 300  # 5 minutes
    
    # Check if process is running
    process_running = check_process(pattern)
    
    if not process_running:
        return ('stopped', 'Not running', C.RED)
    
    # Process is running - check log for details
    log_age = get_log_age_seconds(log_file)
    
    # Special handling for PersRM
    if process_name == 'persrm':
        progress = parse_persrm_progress(log_file)
        
        if progress['state'] == 'loading':
            return ('loading', progress['details'], C.YELLOW)
        elif progress['state'] == 'error':
            return ('error', progress['details'], C.RED)
        elif progress['state'] == 'training':
            if log_age > STALE_THRESHOLD:
                return ('stalled', f"No activity for {format_time_ago(log_age)}", C.YELLOW)
            return ('training', progress['details'], C.GREEN)
        else:
            if log_age > STALE_THRESHOLD:
                return ('stalled', f"No activity for {format_time_ago(log_age)}", C.YELLOW)
            return ('active', 'Running', C.GREEN)
    
    # Generic process state detection
    if log_file and Path(log_file).exists():
        try:
            with open(log_file, 'r') as f:
                lines = f.readlines()
            recent_text = ''.join(lines[-20:]) if len(lines) > 20 else ''.join(lines)
            
            # Check for errors
            if 'ERROR' in recent_text or 'Error:' in recent_text:
                for line in reversed(lines[-10:]):
                    if 'ERROR' in line or 'Error:' in line:
                        return ('error', line.strip()[:50], C.RED)
            
            # Check for loading/initializing
            if 'Starting' in recent_text or 'Initializing' in recent_text or 'Connecting' in recent_text:
                if log_age < 60:  # Only show loading if recent
                    return ('loading', 'Starting up...', C.YELLOW)
            
            # Check staleness
            if log_age > STALE_THRESHOLD:
                return ('stalled', f"No activity for {format_time_ago(log_age)}", C.YELLOW)
            
            # Active
            return ('active', f"Last activity: {format_time_ago(log_age)}", C.GREEN)
            
        except:
            pass
    
    # Fallback - process running but can't determine state
    if log_age > STALE_THRESHOLD:
        return ('stalled', f"Log stale ({format_time_ago(log_age)})", C.YELLOW)
    
    return ('active', 'Running', C.GREEN)


def format_process_status(name, state, details, color):
    """Format a process status line with consistent width."""
    state_icons = {
        'stopped': '‚óã',
        'loading': '‚è≥',
        'training': '‚óè',
        'active': '‚óè',
        'stalled': '‚ö†',
        'error': '‚úó',
    }
    icon = state_icons.get(state, '?')
    return f"  {name:<20} {color}{icon} {state.capitalize()}{C.END} | {details}"


# =============================================================================
# INDIVIDUAL PROCESS MANAGEMENT
# =============================================================================

def perpetual_start():
    """Start Perpetual Trading Learner"""
    ensure_dirs()
    print(f"{C.CYAN}üöÄ Starting Perpetual Trading Learner...{C.END}")
    
    if check_process("perpetual_trading_learner"):
        print(f"  {C.YELLOW}‚óè Already running{C.END}")
        return True
    
    venv = WEBUI_VENV if WEBUI_VENV.exists() else VENV_ACTIVATE
    cmd = f"""cd {PERSRM_DIR} && source {venv} && \\
        nohup python -u perpetual_trading_learner.py \\
            --paper-interval 120 \\
            --backtest-interval 1 \\
            --learning-interval 15 \\
            --threshold 50 \\
            > {LOG_DIR}/perpetual.log 2>&1 &"""
    
    os.system(cmd)
    time.sleep(2)
    
    if check_process("perpetual_trading_learner"):
        print(f"  {C.GREEN}‚úì Perpetual Trading Learner started{C.END}")
        return True
    else:
        print(f"  {C.RED}‚úó Failed to start{C.END}")
        return False


def perpetual_stop():
    """Stop Perpetual Trading Learner"""
    print(f"{C.YELLOW}üõë Stopping Perpetual Trading Learner...{C.END}")
    
    if not check_process("perpetual_trading_learner"):
        print(f"  {C.DIM}Not running{C.END}")
        return True
    
    kill_process("perpetual_trading_learner")
    time.sleep(1)
    print(f"  {C.GREEN}‚úì Stopped{C.END}")
    return True


def perpetual_status():
    """Show Perpetual Trading Learner status with accurate state detection"""
    log_file = LOG_DIR / 'perpetual.log'
    state, details, color = get_process_state('perpetual', 'perpetual_trading_learner', log_file)
    print(format_process_status('Perpetual Trader', state, details, color))
    
    # Show recent log lines
    if log_file.exists() and state != 'stopped':
        print(f"\n  {C.DIM}Recent log:{C.END}")
        with open(log_file) as f:
            for line in f.readlines()[-5:]:
                line = line.strip()[:70]
                if 'ERROR' in line:
                    print(f"    {C.RED}{line}{C.END}")
                elif 'Trade' in line or 'Backtest' in line:
                    print(f"    {C.GREEN}{line}{C.END}")
                else:
                    print(f"    {C.DIM}{line}{C.END}")


def hf_start():
    """Start HF Paper Trader"""
    ensure_dirs()
    print(f"{C.CYAN}üöÄ Starting HF Paper Trader...{C.END}")
    
    if check_process("hf_paper_trader"):
        print(f"  {C.YELLOW}‚óè Already running{C.END}")
        return True
    
    venv = VENV_ACTIVATE
    cmd = f"""cd {PERSRM_DIR} && source {venv} && \\
        nohup python -u hf_paper_trader.py \\
            --interval 15 \\
            --symbols BTC/USDT,ETH/USDT,SOL/USDT \\
            > {HF_LOG_DIR}/hf_trader.log 2>&1 &"""
    
    os.system(cmd)
    time.sleep(2)
    
    if check_process("hf_paper_trader"):
        print(f"  {C.GREEN}‚úì HF Paper Trader started{C.END}")
        return True
    else:
        print(f"  {C.RED}‚úó Failed to start{C.END}")
        return False


def hf_stop():
    """Stop HF Paper Trader"""
    print(f"{C.YELLOW}üõë Stopping HF Paper Trader...{C.END}")
    
    if not check_process("hf_paper_trader"):
        print(f"  {C.DIM}Not running{C.END}")
        return True
    
    kill_process("hf_paper_trader")
    time.sleep(1)
    print(f"  {C.GREEN}‚úì Stopped{C.END}")
    return True


def hf_status():
    """Show HF Paper Trader status with accurate state detection"""
    log_file = HF_LOG_DIR / 'hf_trader.log'
    state, details, color = get_process_state('hf', 'hf_paper_trader', log_file)
    print(format_process_status('HF Paper Trader', state, details, color))
    
    # Show recent log lines
    if log_file.exists() and state != 'stopped':
        print(f"\n  {C.DIM}Recent log:{C.END}")
        with open(log_file) as f:
            for line in f.readlines()[-5:]:
                line = line.strip()[:70]
                if 'ERROR' in line:
                    print(f"    {C.RED}{line}{C.END}")
                elif 'Signal' in line or 'Trade' in line:
                    print(f"    {C.GREEN}{line}{C.END}")
                else:
                    print(f"    {C.DIM}{line}{C.END}")


def persrm_start():
    """Start PersRM Training"""
    ensure_dirs()
    print(f"{C.CYAN}üöÄ Starting PersRM Training...{C.END}")
    
    if check_process("persrm_pytorch"):
        print(f"  {C.YELLOW}‚óè Already running{C.END}")
        return True
    
    # PersRM training script path
    train_script = CHATOS_DIR / 'training/persrm_pytorch_trainer.py'
    if not train_script.exists():
        train_script = PERSRM_DIR / 'persrm_pytorch_trainer.py'
    
    if not train_script.exists():
        print(f"  {C.RED}‚úó Training script not found{C.END}")
        print(f"    Looked in: {CHATOS_DIR / 'training/'}")
        print(f"    And: {PERSRM_DIR}")
        return False
    
    venv = WEBUI_VENV if WEBUI_VENV.exists() else VENV_ACTIVATE
    log_dir = CHATOS_DIR / 'models/persrm-continuous'
    log_dir.mkdir(parents=True, exist_ok=True)
    
    cmd = f"""cd {train_script.parent} && source {venv} && \\
        nohup python -u {train_script.name} \\
            > {log_dir}/training.log 2>&1 &"""
    
    os.system(cmd)
    time.sleep(2)
    
    if check_process("persrm_pytorch"):
        print(f"  {C.GREEN}‚úì PersRM Training started{C.END}")
        return True
    else:
        print(f"  {C.YELLOW}‚ö† Process may have started - check logs{C.END}")
        print(f"    Log: {log_dir}/training.log")
        return False


def persrm_stop():
    """Stop PersRM Training"""
    print(f"{C.YELLOW}üõë Stopping PersRM Training...{C.END}")
    
    if not check_process("persrm_pytorch"):
        print(f"  {C.DIM}Not running{C.END}")
        return True
    
    kill_process("persrm_pytorch")
    time.sleep(1)
    print(f"  {C.GREEN}‚úì Stopped{C.END}")
    return True


def persrm_status():
    """Show PersRM Training status with accurate state detection"""
    state, details, color = get_process_state('persrm', 'persrm_pytorch', PERSRM_LOG)
    print(format_process_status('PersRM Training', state, details, color))
    
    # Show additional details for training state
    if state == 'training':
        progress = parse_persrm_progress(PERSRM_LOG)
        if progress['step']:
            print(f"    {C.DIM}Step: {progress['step']}{C.END}")
    
    # Show recent log lines
    if PERSRM_LOG and PERSRM_LOG.exists() and state != 'stopped':
        print(f"\n  {C.DIM}Recent log:{C.END}")
        with open(PERSRM_LOG) as f:
            for line in f.readlines()[-5:]:
                line = line.strip()[:70]
                if 'Error' in line or 'ERROR' in line:
                    print(f"    {C.RED}{line}{C.END}")
                elif 'Epoch' in line or 'Step' in line:
                    print(f"    {C.CYAN}{line}{C.END}")
                else:
                    print(f"    {C.DIM}{line}{C.END}")


def scraper_start():
    """Start Web Scraper (Docker)"""
    print(f"{C.CYAN}üöÄ Starting Web Scraper...{C.END}")
    
    docker_available = run_cmd("which docker")
    if not docker_available or docker_available.startswith("Error"):
        print(f"  {C.RED}‚úó Docker not available{C.END}")
        return False
    
    # Check if already running
    result = run_cmd("docker ps --format '{{.Names}}' | grep persrm-scraper")
    if result and not result.startswith("Error"):
        print(f"  {C.YELLOW}‚óè Already running{C.END}")
        return True
    
    # Try to start from docker-compose
    compose_file = PERSRM_DIR / 'docker-compose.yml'
    if compose_file.exists():
        os.system(f"cd {PERSRM_DIR} && docker-compose up -d scraper 2>/dev/null || docker-compose up -d persrm-scraper 2>/dev/null")
        time.sleep(2)
        
        result = run_cmd("docker ps --format '{{.Names}}' | grep -i scraper")
        if result:
            print(f"  {C.GREEN}‚úì Web Scraper started{C.END}")
            return True
    
    # Try direct docker run
    print(f"  {C.YELLOW}Trying direct docker run...{C.END}")
    os.system(f"""docker run -d --name persrm-scraper \\
        -v {TRADING_MEMORY}:/data \\
        -v {DATA_4TB if DATA_4TB else TRADING_MEMORY}/synthetic:/output \\
        persrm-scraper:latest 2>/dev/null || echo 'Container may already exist'""")
    
    os.system("docker start persrm-scraper 2>/dev/null")
    time.sleep(1)
    
    result = run_cmd("docker ps --format '{{.Names}}' | grep -i scraper")
    if result:
        print(f"  {C.GREEN}‚úì Web Scraper started{C.END}")
        return True
    else:
        print(f"  {C.RED}‚úó Failed to start Web Scraper{C.END}")
        return False


def scraper_stop():
    """Stop Web Scraper"""
    print(f"{C.YELLOW}üõë Stopping Web Scraper...{C.END}")
    
    os.system("docker stop persrm-scraper 2>/dev/null")
    time.sleep(1)
    print(f"  {C.GREEN}‚úì Stopped{C.END}")
    return True


def scraper_status():
    """Show Web Scraper status with accurate state detection"""
    result = run_cmd("docker ps --format '{{.Names}}\t{{.Status}}' | grep -i scraper")
    
    if not result or result.startswith("Error"):
        print(format_process_status('Web Scraper', 'stopped', 'Container not running', C.RED))
        return
    
    parts = result.split('\t')
    name = parts[0]
    docker_status = parts[1] if len(parts) > 1 else 'unknown'
    
    # Parse docker status for accurate state
    state = 'active'
    color = C.GREEN
    details = docker_status
    
    if 'starting' in docker_status.lower() or 'created' in docker_status.lower():
        state = 'loading'
        color = C.YELLOW
        details = 'Container starting...'
    elif 'unhealthy' in docker_status.lower():
        state = 'error'
        color = C.RED
        details = 'Container unhealthy'
    elif 'exited' in docker_status.lower() or 'dead' in docker_status.lower():
        state = 'stopped'
        color = C.RED
        details = 'Container stopped'
    elif 'Up' in docker_status:
        state = 'active'
        color = C.GREEN
        details = docker_status
    
    print(format_process_status('Web Scraper', state, details, color))
    
    # Show recent logs
    if state != 'stopped':
        logs = run_cmd("docker logs persrm-scraper --tail 5 2>&1")
        if logs and not logs.startswith("Error"):
            print(f"\n  {C.DIM}Recent logs:{C.END}")
            for line in logs.split('\n')[:5]:
                line = line[:70]
                if 'error' in line.lower():
                    print(f"    {C.RED}{line}{C.END}")
                else:
                    print(f"    {C.DIM}{line}{C.END}")


def docker_start():
    """Start all Docker containers"""
    print(f"{C.CYAN}üöÄ Starting Docker Containers...{C.END}")
    
    docker_available = run_cmd("which docker")
    if not docker_available or docker_available.startswith("Error"):
        print(f"  {C.RED}‚úó Docker not available{C.END}")
        return False
    
    compose_files = [
        'docker-compose.trading.yml',
        'docker-compose.hf-trading.yml',
        'docker-compose.yml',
    ]
    
    started = []
    for cf in compose_files:
        compose_file = PERSRM_DIR / cf
        if compose_file.exists():
            os.system(f"cd {PERSRM_DIR} && docker-compose -f {cf} up -d 2>/dev/null")
            started.append(cf)
    
    if started:
        print(f"  {C.GREEN}‚úì Started from: {', '.join(started)}{C.END}")
        time.sleep(2)
        os.system("docker ps --format 'table {{.Names}}\t{{.Status}}' | head -10")
        return True
    else:
        print(f"  {C.YELLOW}No docker-compose files found{C.END}")
        return False


def docker_stop():
    """Stop all Docker containers"""
    print(f"{C.YELLOW}üõë Stopping Docker Containers...{C.END}")
    
    compose_files = [
        'docker-compose.trading.yml',
        'docker-compose.hf-trading.yml',
        'docker-compose.yml',
    ]
    
    for cf in compose_files:
        compose_file = PERSRM_DIR / cf
        if compose_file.exists():
            os.system(f"cd {PERSRM_DIR} && docker-compose -f {cf} down 2>/dev/null")
    
    # Also stop any standalone containers
    os.system("docker stop persrm-scraper persrm-paper-trader 2>/dev/null")
    
    print(f"  {C.GREEN}‚úì All containers stopped{C.END}")
    return True


def docker_status():
    """Show Docker container status"""
    result = run_cmd("docker ps --format 'table {{.Names}}\t{{.Status}}' 2>/dev/null")
    if result and not result.startswith("Error"):
        trading_containers = [l for l in result.split('\n') if 'persrm' in l.lower() or 'trading' in l.lower()]
        if trading_containers:
            print(f"  {C.GREEN}Running containers:{C.END}")
            for line in trading_containers:
                print(f"    {C.GREEN}‚óè {line}{C.END}")
        else:
            print(f"  {C.DIM}No trading containers running{C.END}")
    else:
        print(f"  {C.DIM}Docker not available or no containers{C.END}")


# =============================================================================
# PROCESS COMMAND HANDLERS
# =============================================================================

def handle_process_command(process, action):
    """Handle individual process commands"""
    processes = {
        'perpetual': {
            'start': perpetual_start,
            'stop': perpetual_stop,
            'status': perpetual_status,
            'restart': lambda: (perpetual_stop(), time.sleep(1), perpetual_start()),
        },
        'hf': {
            'start': hf_start,
            'stop': hf_stop,
            'status': hf_status,
            'restart': lambda: (hf_stop(), time.sleep(1), hf_start()),
        },
        'persrm': {
            'start': persrm_start,
            'stop': persrm_stop,
            'status': persrm_status,
            'restart': lambda: (persrm_stop(), time.sleep(1), persrm_start()),
        },
        'scraper': {
            'start': scraper_start,
            'stop': scraper_stop,
            'status': scraper_status,
            'restart': lambda: (scraper_stop(), time.sleep(1), scraper_start()),
        },
        'docker': {
            'start': docker_start,
            'stop': docker_stop,
            'status': docker_status,
        },
    }
    
    if process not in processes:
        print(f"{C.RED}Unknown process: {process}{C.END}")
        print(f"Available: {', '.join(processes.keys())}")
        return
    
    if action not in processes[process]:
        print(f"{C.RED}Unknown action: {action}{C.END}")
        print(f"Available for {process}: {', '.join(processes[process].keys())}")
        return
    
    print_header(f"{process.upper()} - {action.upper()}")
    processes[process][action]()


# =============================================================================
# START/STOP ALL PROCESSES
# =============================================================================

def cmd_start():
    """Start all trading processes"""
    print_header("üöÄ STARTING ALL TRADING PROCESSES")
    
    ensure_dirs()
    
    started = []
    failed = []
    
    # 1. Perpetual Trading Learner
    print_section("Perpetual Trading Learner")
    if perpetual_start():
        started.append("Perpetual Trader")
    else:
        failed.append("Perpetual Trader")
    
    # 2. HF Paper Trader
    print_section("HF Paper Trader")
    if hf_start():
        started.append("HF Paper Trader")
    else:
        failed.append("HF Paper Trader")
    
    # 3. Web Scraper
    print_section("Web Scraper")
    if scraper_start():
        started.append("Web Scraper")
    else:
        failed.append("Web Scraper")
    
    # 4. Docker containers
    print_section("Docker Containers")
    docker_start()
    
    # Summary
    print_section("Summary")
    if started:
        print(f"  {C.GREEN}Started: {', '.join(started)}{C.END}")
    if failed:
        print(f"  {C.RED}Failed: {', '.join(failed)}{C.END}")
    
    print(f"\n{C.CYAN}View logs: trading log{C.END}")
    print(f"{C.CYAN}Check status: trading status{C.END}")


def cmd_stop():
    """Stop all trading processes"""
    print_header("üõë STOPPING ALL TRADING PROCESSES")
    
    stopped = []
    
    # 1. Perpetual Trading Learner
    print_section("Perpetual Trading Learner")
    perpetual_stop()
    stopped.append("Perpetual Trader")
    
    # 2. HF Paper Trader
    print_section("HF Paper Trader")
    hf_stop()
    stopped.append("HF Paper Trader")
    
    # 3. PersRM Training
    print_section("PersRM Training")
    persrm_stop()
    stopped.append("PersRM Training")
    
    # 4. Web Scraper
    print_section("Web Scraper")
    scraper_stop()
    stopped.append("Web Scraper")
    
    # 5. Docker containers
    print_section("Docker Containers")
    docker_stop()
    
    print_section("Summary")
    print(f"  {C.GREEN}All processes stopped{C.END}")


def cmd_restart():
    """Restart all trading processes"""
    print_header("üîÑ RESTARTING ALL TRADING PROCESSES")
    cmd_stop()
    time.sleep(2)
    cmd_start()


# =============================================================================
# LOGGING AND MONITORING
# =============================================================================

def cmd_log(lines=30):
    """Show recent trading logs"""
    print_header("üìã TRADING LOGS")
    
    log_file = LOG_DIR / 'perpetual.log'
    if log_file.exists():
        print_section("Perpetual Trading")
        with open(log_file) as f:
            all_lines = f.readlines()
            for line in all_lines[-lines:]:
                line = line.strip()
                if 'ERROR' in line:
                    print(f"{C.RED}{line}{C.END}")
                elif 'INFO' in line and ('Started' in line or 'Running' in line or 'Completed' in line):
                    print(f"{C.GREEN}{line}{C.END}")
                elif '===' in line:
                    print(f"{C.CYAN}{line}{C.END}")
                else:
                    print(f"{C.DIM}{line}{C.END}")
    else:
        print(f"{C.DIM}No perpetual log found{C.END}")
    
    # HF Trading logs
    hf_log = HF_LOG_DIR / 'hf_trader.log'
    if hf_log.exists():
        print_section("HF Paper Trading")
        with open(hf_log) as f:
            for line in f.readlines()[-8:]:
                print(f"  {line.strip()}")
    
    # PersRM training log
    print_section("PersRM Training")
    if PERSRM_LOG and PERSRM_LOG.exists():
        with open(PERSRM_LOG) as f:
            for line in f.readlines()[-8:]:
                print(f"  {line.strip()}")
    else:
        print(f"  {C.DIM}No training log found{C.END}")


def cmd_stats():
    """Show trading statistics with staleness warnings"""
    print_header("üìä TRADING STATISTICS")
    
    stats_file = TRADING_MEMORY / 'stats.json'
    if stats_file.exists():
        # Check staleness of stats file
        stats_age = get_log_age_seconds(stats_file)
        if stats_age > 3600:  # More than 1 hour old
            print(f"  {C.YELLOW}‚ö† Warning: Stats data may be stale (last update: {format_time_ago(stats_age)}){C.END}\n")
        
        with open(stats_file) as f:
            stats = json.load(f)
        
        print_section("Session Info")
        print(f"  Started:     {stats.get('start_time', 'N/A')}")
        print(f"  Uptime:      {stats.get('uptime_hours', 0):.1f} hours")
        print(f"  Last Update: {stats.get('last_update', 'N/A')}")
        print(f"  File Age:    {format_time_ago(stats_age)}")
        
        print_section("Trading Performance")
        total = stats.get('total_trades', 0)
        wins = stats.get('winning_trades', 0)
        losses = stats.get('losing_trades', 0)
        win_rate = (wins / total * 100) if total > 0 else 0
        
        print(f"  Total Trades:   {C.BOLD}{total}{C.END}")
        print(f"  Winning:        {C.GREEN}{wins}{C.END}")
        print(f"  Losing:         {C.RED}{losses}{C.END}")
        print(f"  Win Rate:       {C.BOLD}{win_rate:.1f}%{C.END}")
        
        print_section("Learning Progress")
        print(f"  Training Runs:     {stats.get('training_runs', 0)}")
        print(f"  Examples Generated: {stats.get('examples_generated', 0)}")
        print(f"  Backtests Done:    {stats.get('backtests_completed', 0)}")
    else:
        print(f"{C.YELLOW}No stats file yet. System may still be initializing.{C.END}")
    
    # Training data count
    train_file = CHATOS_DIR / 'data/persrm/train.jsonl' if CHATOS_DIR else None
    if train_file and train_file.exists():
        with open(train_file) as f:
            count = sum(1 for _ in f)
        print_section("Training Data")
        print(f"  Total Examples: {C.BOLD}{count}{C.END}")
    
    # PersRM Training progress
    if PERSRM_LOG and PERSRM_LOG.exists():
        progress = parse_persrm_progress(PERSRM_LOG)
        if progress['state'] == 'training' and progress['epoch']:
            print_section("PersRM Training Progress")
            print(f"  Status:   {C.GREEN}‚óè Training{C.END}")
            print(f"  Progress: Epoch {progress['epoch']}/{progress['total_epochs']} ({progress['percent']:.1f}%)")
            if progress['loss']:
                print(f"  Loss:     {progress['loss']:.4f}")
            if progress['step']:
                print(f"  Step:     {progress['step']}")


def cmd_trades(count=20):
    """Show recent trades"""
    print_header("üí∞ RECENT TRADES")
    
    trade_files = sorted(TRADES_DIR.glob('trades_*.jsonl'), reverse=True)
    
    if not trade_files:
        print(f"{C.YELLOW}No trades recorded yet.{C.END}")
        return
    
    trades = []
    for tf in trade_files[:3]:
        with open(tf) as f:
            for line in f:
                if line.strip():
                    trades.append(json.loads(line))
    
    trades = sorted(trades, key=lambda x: x.get('timestamp', ''), reverse=True)[:count]
    
    if not trades:
        print(f"{C.YELLOW}No trades recorded yet.{C.END}")
        return
    
    print(f"{'Time':<20} {'Symbol':<12} {'Side':<6} {'Entry':>12} {'Exit':>12} {'P&L':>12}")
    print(f"{C.DIM}{'‚îÄ' * 76}{C.END}")
    
    for t in trades:
        ts = t.get('timestamp', '')[:19]
        symbol = t.get('symbol', 'N/A')
        side = t.get('side', 'N/A')
        entry = t.get('entry_price', 0)
        exit_p = t.get('exit_price', 0)
        pnl = t.get('pnl', 0)
        
        color = C.GREEN if pnl > 0 else C.RED if pnl < 0 else C.DIM
        print(f"{ts:<20} {symbol:<12} {side:<6} ${entry:>10,.2f} ${exit_p:>10,.2f} {color}${pnl:>+10,.2f}{C.END}")


def cmd_view():
    """Live monitoring view with accurate state detection"""
    print_header("üî¥ LIVE TRADING VIEW")
    print(f"{C.DIM}Press Ctrl+C to exit{C.END}\n")
    
    try:
        while True:
            os.system('clear')
            print_header("üî¥ LIVE TRADING VIEW")
            print(f"{C.DIM}Updated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} | Ctrl+C to exit | {'macOS' if IS_MAC else 'Linux'}{C.END}")
            
            # Quick stats with staleness check
            stats_file = TRADING_MEMORY / 'stats.json'
            if stats_file.exists():
                stats_age = get_log_age_seconds(stats_file)
                with open(stats_file) as f:
                    stats = json.load(f)
                total = stats.get('total_trades', 0)
                wins = stats.get('winning_trades', 0)
                wr = (wins / total * 100) if total > 0 else 0
                stats_warning = f" {C.YELLOW}(stale: {format_time_ago(stats_age)}){C.END}" if stats_age > 3600 else ""
                print(f"\n{C.BOLD}Trades: {total} | Win Rate: {wr:.1f}% | Examples: {stats.get('examples_generated', 0)}{C.END}{stats_warning}")
            
            # Process status with accurate state detection
            print_section("Process Status")
            processes = [
                ('Perpetual Trader', 'perpetual_trading_learner', 'perpetual', LOG_DIR / 'perpetual.log'),
                ('HF Paper Trader', 'hf_paper_trader', 'hf', HF_LOG_DIR / 'hf_trader.log'),
                ('PersRM Training', 'persrm_pytorch', 'persrm', PERSRM_LOG),
            ]
            
            for name, pattern, proc_type, log_file in processes:
                state, details, color = get_process_state(proc_type, pattern, log_file)
                # Compact format for live view
                state_icons = {'stopped': '‚óã', 'loading': '‚è≥', 'training': '‚óè', 'active': '‚óè', 'stalled': '‚ö†', 'error': '‚úó'}
                icon = state_icons.get(state, '?')
                print(f"  {color}{icon} {name:<18}{C.END} {C.DIM}{details[:40]}{C.END}")
            
            # Web Scraper (Docker)
            result = run_cmd("docker ps --format '{{.Names}}\t{{.Status}}' | grep -i scraper")
            if result and not result.startswith("Error"):
                parts = result.split('\t')
                docker_status = parts[1] if len(parts) > 1 else 'running'
                print(f"  {C.GREEN}‚óè Web Scraper       {C.END} {C.DIM}{docker_status[:40]}{C.END}")
            else:
                print(f"  {C.RED}‚óã Web Scraper       {C.END} {C.DIM}Not running{C.END}")
            
            # Recent activity
            print_section("Recent Activity")
            log_file = LOG_DIR / 'perpetual.log'
            if log_file.exists():
                with open(log_file) as f:
                    for line in f.readlines()[-6:]:
                        line = line.strip()
                        if 'ERROR' in line:
                            print(f"  {C.RED}{line[-70:]}{C.END}")
                        elif 'Trade' in line or 'Backtest' in line:
                            print(f"  {C.GREEN}{line[-70:]}{C.END}")
                        else:
                            print(f"  {C.DIM}{line[-70:]}{C.END}")
            
            # PersRM Training progress
            if PERSRM_LOG and PERSRM_LOG.exists():
                progress = parse_persrm_progress(PERSRM_LOG)
                if progress['state'] == 'training' and progress['epoch']:
                    print_section("PersRM Training")
                    bar_width = 30
                    filled = int(bar_width * progress['percent'] / 100)
                    bar = '‚ñà' * filled + '‚ñë' * (bar_width - filled)
                    print(f"  [{bar}] {progress['percent']:.1f}%")
                    print(f"  Epoch {progress['epoch']}/{progress['total_epochs']} | Loss: {progress['loss']:.4f}" if progress['loss'] else f"  Epoch {progress['epoch']}/{progress['total_epochs']}")
            
            time.sleep(5)
            
    except KeyboardInterrupt:
        print(f"\n{C.YELLOW}Exiting live view...{C.END}")


def cmd_status():
    """Show system status with accurate state detection"""
    print_header("‚ö° SYSTEM STATUS")
    
    print(f"  Platform: {C.CYAN}{'macOS' if IS_MAC else 'Linux'}{C.END}")
    print(f"  Home: {C.DIM}{HOME}{C.END}")
    
    print_section("Process Status")
    
    # Define processes with their log files
    processes = [
        ('Perpetual Trader', 'perpetual_trading_learner', 'perpetual', LOG_DIR / 'perpetual.log'),
        ('HF Paper Trader', 'hf_paper_trader', 'hf', HF_LOG_DIR / 'hf_trader.log'),
        ('PersRM Training', 'persrm_pytorch', 'persrm', PERSRM_LOG),
    ]
    
    for name, pattern, proc_type, log_file in processes:
        state, details, color = get_process_state(proc_type, pattern, log_file)
        print(format_process_status(name, state, details, color))
    
    # Web Scraper (Docker) - special handling
    result = run_cmd("docker ps --format '{{.Names}}\t{{.Status}}' | grep -i scraper")
    if result and not result.startswith("Error"):
        parts = result.split('\t')
        docker_status = parts[1] if len(parts) > 1 else 'running'
        
        if 'unhealthy' in docker_status.lower():
            print(format_process_status('Web Scraper', 'error', 'Container unhealthy', C.RED))
        elif 'starting' in docker_status.lower():
            print(format_process_status('Web Scraper', 'loading', 'Starting...', C.YELLOW))
        else:
            print(format_process_status('Web Scraper', 'active', docker_status, C.GREEN))
    else:
        print(format_process_status('Web Scraper', 'stopped', 'Not running', C.RED))
    
    # Docker containers
    print_section("Docker Containers")
    result = run_cmd("docker ps --format '{{.Names}}\t{{.Status}}' 2>/dev/null | grep -E 'persrm|trading'")
    if result and not result.startswith("Error") and result:
        for line in result.split('\n'):
            if line:
                parts = line.split('\t')
                name = parts[0] if parts else line
                status = parts[1] if len(parts) > 1 else 'unknown'
                print(f"  {C.GREEN}‚óè {name}: {status}{C.END}")
    else:
        print(f"  {C.DIM}No Docker containers running{C.END}")
    
    # GPU status
    print_section("GPU")
    if not IS_MAC:
        result = run_cmd("nvidia-smi --query-gpu=utilization.gpu,memory.used,memory.total,temperature.gpu --format=csv,noheader 2>/dev/null")
        if result and not result.startswith("Error"):
            parts = result.split(', ')
            if len(parts) >= 4:
                util, mem_used, mem_total, temp = parts
                print(f"  Utilization: {C.BOLD}{util}{C.END}")
                print(f"  Memory:      {mem_used} / {mem_total}")
                print(f"  Temperature: {temp}")
        else:
            print(f"  {C.DIM}No NVIDIA GPU found{C.END}")
    else:
        result = run_cmd("sysctl -n machdep.cpu.brand_string 2>/dev/null")
        if result:
            print(f"  CPU: {result}")
    
    # Disk space
    print_section("Storage")
    result = run_cmd(f"df -h {TRADING_MEMORY} 2>/dev/null | tail -1")
    if result and not result.startswith("Error"):
        parts = result.split()
        if len(parts) >= 5:
            print(f"  TradingMemory: {parts[2]} used / {parts[1]} total ({parts[4]} full)")


def cmd_paths():
    """Show configured paths"""
    print_header("üìÅ CONFIGURED PATHS")
    
    print(f"  Platform:       {'macOS' if IS_MAC else 'Linux'}")
    print(f"  Home:           {HOME}")
    print(f"  Trading Memory: {TRADING_MEMORY}")
    print(f"  PersRM Dir:     {PERSRM_DIR}")
    print(f"  ChatOS Dir:     {CHATOS_DIR}")
    print(f"  Log Dir:        {LOG_DIR}")
    print(f"  Trades Dir:     {TRADES_DIR}")
    print(f"  HF Log Dir:     {HF_LOG_DIR}")
    if DATA_4TB:
        print(f"  Data 4TB:       {DATA_4TB}")


def show_help():
    """Show help message"""
    print(f"""
{C.CYAN}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë  {C.BOLD}PersRM Trading Intelligence CLI{C.END}{C.CYAN}                         ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù{C.END}

{C.BOLD}Platform:{C.END} {'macOS' if IS_MAC else 'Linux'}

{C.BOLD}Process Management (ALL):{C.END}
    {C.GREEN}start{C.END}              Start ALL trading processes
    {C.GREEN}stop{C.END}               Stop ALL trading processes
    {C.GREEN}restart{C.END}            Restart all processes

{C.BOLD}Individual Process Control:{C.END}
    {C.GREEN}perpetual start{C.END}    Start Perpetual Trading Learner
    {C.GREEN}perpetual stop{C.END}     Stop Perpetual Trading Learner
    {C.GREEN}perpetual restart{C.END}  Restart Perpetual Trading Learner
    {C.GREEN}perpetual status{C.END}   Show status

    {C.GREEN}hf start{C.END}           Start HF Paper Trader
    {C.GREEN}hf stop{C.END}            Stop HF Paper Trader
    {C.GREEN}hf restart{C.END}         Restart HF Paper Trader
    {C.GREEN}hf status{C.END}          Show status

    {C.GREEN}persrm start{C.END}       Start PersRM Training
    {C.GREEN}persrm stop{C.END}        Stop PersRM Training
    {C.GREEN}persrm restart{C.END}     Restart PersRM Training
    {C.GREEN}persrm status{C.END}      Show status

    {C.GREEN}scraper start{C.END}      Start Web Scraper (Docker)
    {C.GREEN}scraper stop{C.END}       Stop Web Scraper
    {C.GREEN}scraper status{C.END}     Show status

    {C.GREEN}docker start{C.END}       Start all Docker containers
    {C.GREEN}docker stop{C.END}        Stop all Docker containers
    {C.GREEN}docker status{C.END}      Show container status

{C.BOLD}Monitoring:{C.END}
    {C.GREEN}log{C.END}                View recent trading logs
    {C.GREEN}stats{C.END}              Show trading statistics  
    {C.GREEN}trades{C.END}             Recent trade history
    {C.GREEN}view{C.END}               Live monitoring dashboard
    {C.GREEN}status{C.END}             System status overview
    {C.GREEN}paths{C.END}              Show configured paths

{C.BOLD}Examples:{C.END}
    trading start              # Start all processes
    trading perpetual start    # Start only Perpetual Trader
    trading hf stop            # Stop only HF Trader
    trading scraper restart    # Restart web scraper
    trading status             # Check all systems
""")


def main():
    args = sys.argv[1:]
    
    if not args:
        show_help()
        return
    
    # Check for two-word commands (process + action)
    if len(args) >= 2:
        process = args[0].lower()
        action = args[1].lower()
        
        if process in ['perpetual', 'hf', 'persrm', 'scraper', 'docker']:
            handle_process_command(process, action)
            return
    
    # Single word commands
    cmd = args[0].lower().strip('-')
    
    commands = {
        # Process management (all)
        'start': cmd_start,
        'start-all': cmd_start,
        'startall': cmd_start,
        'stop': cmd_stop,
        'stop-all': cmd_stop,
        'stopall': cmd_stop,
        'restart': cmd_restart,
        
        # Monitoring
        'log': cmd_log,
        'logs': cmd_log,
        'stats': cmd_stats,
        'statistics': cmd_stats,
        'trades': cmd_trades,
        'trade': cmd_trades,
        'view': cmd_view,
        'live': cmd_view,
        'status': cmd_status,
        
        # Help
        'help': show_help,
        'h': show_help,
        '-h': show_help,
        '--help': show_help,
        'paths': cmd_paths,
    }
    
    if cmd in commands:
        commands[cmd]()
    else:
        print(f"{C.RED}Unknown command: {cmd}{C.END}")
        show_help()


if __name__ == '__main__':
    main()
