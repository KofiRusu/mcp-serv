[
  {
    "id": "f1e11850-1b83-4964-99de-07069719a54d",
    "name": "A2",
    "description": "",
    "type": "scraper",
    "status": "testing",
    "deployment_type": "docker",
    "blocks": [
      {
        "id": "block-1765395546076-nezgtx2m7qe",
        "type": "source",
        "name": "Binance WebSocket",
        "config": {
          "symbol": "BTCUSDT",
          "stream": "btcusdt@aggTrade"
        },
        "position": {
          "x": 100.0,
          "y": 100.0
        },
        "connections": []
      },
      {
        "id": "block-1765395567293-5j7inrbqi2y",
        "type": "indicator",
        "name": "RSI",
        "config": {
          "period": 14,
          "overbought": 70,
          "oversold": 30
        },
        "position": {
          "x": 436.66668701171875,
          "y": 36.5
        },
        "connections": [
          "block-1765395546076-nezgtx2m7qe",
          "block-1765395624818-u6jyp9qeif",
          "block-1765395700238-48uktcjz387"
        ]
      },
      {
        "id": "block-1765395591366-bho7jbq1ski",
        "type": "indicator",
        "name": "MACD",
        "config": {
          "fast": 12,
          "slow": 26,
          "signal": 9
        },
        "position": {
          "x": 411.83331298828125,
          "y": 222.066650390625
        },
        "connections": [
          "block-1765395567293-5j7inrbqi2y",
          "block-1765395546076-nezgtx2m7qe",
          "block-1765395624818-u6jyp9qeif",
          "block-1765395700238-48uktcjz387"
        ]
      },
      {
        "id": "block-1765395609515-lmc5ou41ysi",
        "type": "indicator",
        "name": "Money V1 (Structure)",
        "config": {
          "period": 20
        },
        "position": {
          "x": 406.75,
          "y": 452.75
        },
        "connections": [
          "block-1765395546076-nezgtx2m7qe",
          "block-1765395624818-u6jyp9qeif",
          "block-1765395700238-48uktcjz387"
        ]
      },
      {
        "id": "block-1765395624818-u6jyp9qeif",
        "type": "stop_loss",
        "name": "Stop Loss",
        "config": {
          "type": "percent",
          "value": 2
        },
        "position": {
          "x": 748.6666870117188,
          "y": 201.86666870117188
        },
        "connections": []
      },
      {
        "id": "block-1765395700238-48uktcjz387",
        "type": "take_profit",
        "name": "Take Profit",
        "config": {
          "type": "percent",
          "value": 4
        },
        "position": {
          "x": 729.75,
          "y": 386.1499938964844
        },
        "connections": []
      },
      {
        "id": "block-1765395762524-zapd3p6tsd9",
        "type": "entry",
        "name": "Entry Signal",
        "config": {
          "type": "market"
        },
        "position": {
          "x": 1143.9166259765625,
          "y": 278.9166717529297
        },
        "connections": [
          "block-1765395624818-u6jyp9qeif",
          "block-1765395700238-48uktcjz387"
        ]
      }
    ],
    "generated_code": "#!/usr/bin/env python3\n\"\"\"\nAuto-generated automation script.\nAutomation: A2\nGenerated: 2025-12-12T15:23:06.608487\n\"\"\"\n\nimport asyncio\nimport json\nimport time\nimport logging\nfrom datetime import datetime\nfrom typing import Dict, List, Any, Optional\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s | %(levelname)s | %(message)s',\n    datefmt='%H:%M:%S'\n)\nlogger = logging.getLogger(__name__)\n\n\nimport websockets\n\n\n\nimport pandas as pd\n\n\nimport numpy as np\n\n\ntry:\n    import pandas_ta as ta\nexcept ImportError:\n    logger.warning(\"pandas_ta not installed, some indicators may not work\")\n    ta = None\n\n\n# Output directory for this automation\nOUTPUT_DIR = Path(\"/home/kr/ChatOS-v2.1/sandbox-ui/data/automations/f1e11850-1b83-4964-99de-07069719a54d\")\nOUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n\n# Block state storage\nblock_outputs: Dict[str, Any] = {}\nblock_states: Dict[str, Dict] = {}\n\n\n@dataclass\nclass MarketData:\n    \"\"\"Market data from sources.\"\"\"\n    symbol: str\n    price: float\n    volume: float = 0.0\n    timestamp: float = field(default_factory=time.time)\n    bid: float = 0.0\n    ask: float = 0.0\n    extra: Dict = field(default_factory=dict)\n\n@dataclass\nclass Signal:\n    \"\"\"Trading signal from indicators/conditions.\"\"\"\n    name: str\n    value: Any\n    direction: str = \"neutral\"  # bullish, bearish, neutral\n    strength: float = 0.0  # 0.0 to 1.0\n    timestamp: float = field(default_factory=time.time)\n    metadata: Dict = field(default_factory=dict)\n\n@dataclass\nclass Order:\n    \"\"\"Order to be executed.\"\"\"\n    symbol: str\n    side: str  # buy, sell\n    order_type: str  # market, limit\n    quantity: float\n    price: Optional[float] = None\n    stop_loss: Optional[float] = None\n    take_profit: Optional[float] = None\n    metadata: Dict = field(default_factory=dict)\n\n@dataclass\nclass RiskCheck:\n    \"\"\"Result of risk validation.\"\"\"\n    approved: bool\n    reason: str = \"\"\n    adjusted_quantity: Optional[float] = None\n\n\n\ndef save_output(filename: str, data: Any):\n    \"\"\"Save data to output directory.\"\"\"\n    filepath = OUTPUT_DIR / filename\n    with open(filepath, 'w') as f:\n        if isinstance(data, (dict, list)):\n            json.dump(data, f, indent=2, default=str)\n        else:\n            f.write(str(data))\n    logger.info(f\"Saved output to {filepath}\")\n\ndef load_state(block_id: str) -> Dict:\n    \"\"\"Load persisted state for a block.\"\"\"\n    state_file = OUTPUT_DIR / f\".state_{block_id}.json\"\n    if state_file.exists():\n        with open(state_file) as f:\n            return json.load(f)\n    return {}\n\ndef save_state(block_id: str, state: Dict):\n    \"\"\"Persist state for a block.\"\"\"\n    state_file = OUTPUT_DIR / f\".state_{block_id}.json\"\n    with open(state_file, 'w') as f:\n        json.dump(state, f)\n\n\n\nasync def block_1765395591366_bho7jbq1ski_indicator(input_data):\n    \"\"\"\n    MACD Indicator: MACD\n    Fast: 12, Slow: 26, Signal: 9\n    \"\"\"\n    logger.info(\"\ud83d\udcc8 Calculating MACD...\")\n    \n    # Get price data\n    if isinstance(input_data, list):\n        prices = [d.price if hasattr(d, 'price') else d.get('close', d.get('price', 0)) for d in input_data]\n    elif hasattr(input_data, 'price'):\n        state = block_states.get('block_1765395591366_bho7jbq1ski', {'prices': []})\n        state['prices'].append(input_data.price)\n        state['prices'] = state['prices'][-45:]\n        block_states['block_1765395591366_bho7jbq1ski'] = state\n        prices = state['prices']\n    else:\n        prices = [input_data]\n    \n    min_periods = 26 + 9\n    if len(prices) < min_periods:\n        logger.warning(f\"Not enough data for MACD (need {min_periods}, have {len(prices)})\")\n        return Signal(name=\"MACD\", value=0, direction=\"neutral\", strength=0)\n    \n    if ta is not None:\n        df = pd.DataFrame({'close': prices})\n        macd_df = ta.macd(df['close'], fast=12, slow=26, signal=9)\n        macd_value = macd_df.iloc[-1, 0]  # MACD line\n        signal_value = macd_df.iloc[-1, 2]  # Signal line\n        histogram = macd_df.iloc[-1, 1]  # Histogram\n    else:\n        # Manual EMA calculation\n        def ema(data, period):\n            multiplier = 2 / (period + 1)\n            ema_val = sum(data[:period]) / period\n            for price in data[period:]:\n                ema_val = (price - ema_val) * multiplier + ema_val\n            return ema_val\n        \n        fast_ema = ema(prices, 12)\n        slow_ema = ema(prices, 26)\n        macd_value = fast_ema - slow_ema\n        signal_value = 0  # Simplified\n        histogram = macd_value\n    \n    # Determine signal\n    if histogram > 0:\n        direction = \"bullish\"\n        strength = min(1.0, abs(histogram) / 100)\n    elif histogram < 0:\n        direction = \"bearish\"\n        strength = min(1.0, abs(histogram) / 100)\n    else:\n        direction = \"neutral\"\n        strength = 0\n    \n    signal = Signal(\n        name=\"MACD\",\n        value=macd_value,\n        direction=direction,\n        strength=strength,\n        metadata={\n            'macd': macd_value,\n            'signal': signal_value,\n            'histogram': histogram\n        }\n    )\n    \n    block_outputs['block_1765395591366_bho7jbq1ski'] = signal\n    logger.info(f\"\ud83d\udcca MACD: {macd_value:.4f} | Histogram: {histogram:.4f} \u2192 {direction.upper()}\")\n    \n    return signal\n\nasync def block_1765395609515_lmc5ou41ysi_indicator(input_data):\n    \"\"\"\n    Money V1 - Market Structure: Money V1 (Structure)\n    Period: 20\n    \"\"\"\n    logger.info(\"\ud83d\udcc8 Analyzing Market Structure...\")\n    \n    # Get price data\n    if isinstance(input_data, list):\n        prices = [d.price if hasattr(d, 'price') else d.get('close', d.get('price', 0)) for d in input_data]\n    elif hasattr(input_data, 'price'):\n        state = block_states.get('block_1765395609515_lmc5ou41ysi', {'prices': []})\n        state['prices'].append(input_data.price)\n        state['prices'] = state['prices'][-60:]\n        block_states['block_1765395609515_lmc5ou41ysi'] = state\n        prices = state['prices']\n    else:\n        prices = [input_data]\n    \n    if len(prices) < 20:\n        return Signal(name=\"Structure\", value=\"Insufficient Data\", direction=\"neutral\", strength=0)\n    \n    # Find swing highs and lows\n    swing_highs = []\n    swing_lows = []\n    lookback = 20 // 4\n    \n    for i in range(lookback, len(prices) - lookback):\n        if prices[i] == max(prices[i-lookback:i+lookback+1]):\n            swing_highs.append((i, prices[i]))\n        if prices[i] == min(prices[i-lookback:i+lookback+1]):\n            swing_lows.append((i, prices[i]))\n    \n    # Determine structure\n    structure = \"Ranging\"\n    direction = \"neutral\"\n    \n    if len(swing_highs) >= 2 and len(swing_lows) >= 2:\n        # Higher highs and higher lows = Uptrend\n        if swing_highs[-1][1] > swing_highs[-2][1] and swing_lows[-1][1] > swing_lows[-2][1]:\n            structure = \"Uptrend (HH, HL)\"\n            direction = \"bullish\"\n        # Lower highs and lower lows = Downtrend\n        elif swing_highs[-1][1] < swing_highs[-2][1] and swing_lows[-1][1] < swing_lows[-2][1]:\n            structure = \"Downtrend (LH, LL)\"\n            direction = \"bearish\"\n        # Break of structure\n        elif swing_highs[-1][1] > swing_highs[-2][1] and swing_lows[-1][1] < swing_lows[-2][1]:\n            structure = \"Break of Structure (BOS)\"\n            direction = \"bullish\"\n        elif swing_highs[-1][1] < swing_highs[-2][1] and swing_lows[-1][1] > swing_lows[-2][1]:\n            structure = \"Break of Structure (BOS)\"\n            direction = \"bearish\"\n    \n    signal = Signal(\n        name=\"MarketStructure\",\n        value=structure,\n        direction=direction,\n        strength=0.7 if direction != \"neutral\" else 0,\n        metadata={\n            'swing_highs': swing_highs[-3:] if swing_highs else [],\n            'swing_lows': swing_lows[-3:] if swing_lows else [],\n        }\n    )\n    \n    block_outputs['block_1765395609515_lmc5ou41ysi'] = signal\n    logger.info(f\"\ud83e\udde0 Market Structure: {structure}\")\n    \n    return signal\n\nasync def block_1765395567293_5j7inrbqi2y_indicator(input_data):\n    \"\"\"\n    RSI Indicator: RSI\n    Period: 14\n    Overbought: 70\n    Oversold: 30\n    \"\"\"\n    logger.info(\"\ud83d\udcc8 Calculating RSI...\")\n    \n    # Get price data\n    if isinstance(input_data, list):\n        prices = [d.price if hasattr(d, 'price') else d.get('close', d.get('price', 0)) for d in input_data]\n    elif hasattr(input_data, 'price'):\n        # Single data point - use stored history\n        state = block_states.get('block_1765395567293_5j7inrbqi2y', {'prices': []})\n        state['prices'].append(input_data.price)\n        state['prices'] = state['prices'][-24:]  # Keep enough for calculation\n        block_states['block_1765395567293_5j7inrbqi2y'] = state\n        prices = state['prices']\n    else:\n        prices = [input_data]\n    \n    if len(prices) < 14:\n        logger.warning(f\"Not enough data for RSI (need 14, have {len(prices)})\")\n        return Signal(name=\"RSI\", value=50, direction=\"neutral\", strength=0)\n    \n    # Calculate RSI\n    if ta is not None:\n        df = pd.DataFrame({'close': prices})\n        df['rsi'] = ta.rsi(df['close'], length=14)\n        rsi_value = df['rsi'].iloc[-1]\n    else:\n        # Manual RSI calculation\n        deltas = [prices[i] - prices[i-1] for i in range(1, len(prices))]\n        gains = [d if d > 0 else 0 for d in deltas[-14:]]\n        losses = [-d if d < 0 else 0 for d in deltas[-14:]]\n        avg_gain = sum(gains) / 14\n        avg_loss = sum(losses) / 14\n        rs = avg_gain / avg_loss if avg_loss != 0 else 100\n        rsi_value = 100 - (100 / (1 + rs))\n    \n    # Determine signal\n    if rsi_value >= 70:\n        direction = \"bearish\"\n        strength = (rsi_value - 70) / (100 - 70)\n    elif rsi_value <= 30:\n        direction = \"bullish\"\n        strength = (30 - rsi_value) / 30\n    else:\n        direction = \"neutral\"\n        strength = 0\n    \n    signal = Signal(\n        name=\"RSI\",\n        value=rsi_value,\n        direction=direction,\n        strength=min(1.0, strength),\n        metadata={'period': 14}\n    )\n    \n    block_outputs['block_1765395567293_5j7inrbqi2y'] = signal\n    logger.info(f\"\ud83d\udcca RSI(14): {rsi_value:.2f} \u2192 {direction.upper()}\")\n    \n    return signal\n\nasync def block_1765395546076_nezgtx2m7qe_source():\n    \"\"\"\n    Binance WebSocket Source: Binance WebSocket\n    Symbol: BTCUSDT\n    Stream: btcusdt@aggTrade\n    \"\"\"\n    logger.info(\"\ud83d\udd0c Connecting to Binance WebSocket for BTCUSDT...\")\n    \n    uri = \"wss://stream.binance.com:9443/ws/btcusdt@btcusdt@aggTrade\"\n    \n    try:\n        async with websockets.connect(uri) as ws:\n            logger.info(\"\u2713 Connected to Binance WebSocket\")\n            \n            async for message in ws:\n                data = json.loads(message)\n                \n                # Parse based on stream type\n                \n                market_data = MarketData(\n                    symbol=\"BTCUSDT\",\n                    price=float(data.get('p', data.get('c', 0))),\n                    volume=float(data.get('q', data.get('v', 0))),\n                    extra=data\n                )\n                \n                \n                block_outputs['block_1765395546076_nezgtx2m7qe'] = market_data\n                logger.info(f\"\ud83d\udcca BTCUSDT: ${market_data.price:,.2f}\")\n                \n                yield market_data\n                \n    except Exception as e:\n        logger.error(f\"WebSocket error: {e}\")\n        raise\n\nasync def block_1765395762524_zapd3p6tsd9_entry(input_signals):\n    \"\"\"\n    Entry Signal: Entry Signal\n    Type: market\n    \"\"\"\n    logger.info(\"\ud83d\udfe2 Evaluating Entry Conditions...\")\n    \n    # Collect all input signals\n    if not isinstance(input_signals, list):\n        input_signals = [input_signals]\n    \n    bullish_signals = []\n    bearish_signals = []\n    total_strength = 0\n    \n    for sig in input_signals:\n        if hasattr(sig, 'direction'):\n            if sig.direction == \"bullish\":\n                bullish_signals.append(sig)\n                total_strength += sig.strength\n            elif sig.direction == \"bearish\":\n                bearish_signals.append(sig)\n    \n    # Determine entry\n    entry_signal = None\n    \n    \n    # Market entry - enter on any strong signal\n    if bullish_signals and total_strength >= 0.5:\n        entry_signal = {\n            'side': 'buy',\n            'type': 'market',\n            'confidence': total_strength / len(bullish_signals),\n            'signals': [s.name for s in bullish_signals],\n        }\n    \n    \n    if entry_signal:\n        logger.info(f\"\u2713 ENTRY SIGNAL: {entry_signal['side'].upper()} | Confidence: {entry_signal['confidence']:.2f}\")\n        logger.info(f\"  Triggered by: {', '.join(entry_signal['signals'])}\")\n    else:\n        logger.info(\"\u2717 No entry signal\")\n    \n    block_outputs['block_1765395762524_zapd3p6tsd9'] = entry_signal\n    return entry_signal\n\nasync def block_1765395624818_u6jyp9qeif_stop_loss(input_data):\n    \"\"\"\n    Stop Loss: Stop Loss\n    Type: percent\n    Value: 2%\n    \"\"\"\n    logger.info(\"\ud83d\uded1 Calculating Stop Loss...\")\n    \n    # Get entry price from input or block outputs\n    entry_price = 0\n    current_price = 0\n    \n    if isinstance(input_data, dict):\n        entry_price = input_data.get('fill_price', input_data.get('price', 0))\n    \n    for key, value in block_outputs.items():\n        if hasattr(value, 'price'):\n            current_price = value.price\n            if entry_price == 0:\n                entry_price = value.price\n    \n    \n    # Percentage-based stop\n    stop_price = entry_price * (1 - 2 / 100)\n    \n    \n    # Check if stop is triggered\n    triggered = current_price > 0 and current_price <= stop_price\n    \n    result = {\n        'stop_price': stop_price,\n        'entry_price': entry_price,\n        'current_price': current_price,\n        'triggered': triggered,\n        'type': 'percent',\n    }\n    \n    if triggered:\n        logger.warning(f\"\ud83d\udea8 STOP LOSS TRIGGERED @ ${stop_price:,.2f}\")\n    else:\n        logger.info(f\"\ud83d\uded1 Stop Loss: ${stop_price:,.2f} (Entry: ${entry_price:,.2f})\")\n    \n    block_outputs['block_1765395624818_u6jyp9qeif'] = result\n    return result\n\nasync def block_1765395700238_48uktcjz387_take_profit(input_data):\n    \"\"\"\n    Take Profit: Take Profit\n    Type: percent\n    Value: 4%\n    \"\"\"\n    logger.info(\"\ud83c\udfaf Calculating Take Profit...\")\n    \n    # Get entry price from input or block outputs\n    entry_price = 0\n    current_price = 0\n    \n    if isinstance(input_data, dict):\n        entry_price = input_data.get('fill_price', input_data.get('price', 0))\n    \n    for key, value in block_outputs.items():\n        if hasattr(value, 'price'):\n            current_price = value.price\n            if entry_price == 0:\n                entry_price = value.price\n    \n    \n    # Percentage-based take profit\n    target_price = entry_price * (1 + 4 / 100)\n    \n    \n    # Check if target is reached\n    triggered = current_price > 0 and current_price >= target_price\n    \n    result = {\n        'target_price': target_price,\n        'entry_price': entry_price,\n        'current_price': current_price,\n        'triggered': triggered,\n        'type': 'percent',\n    }\n    \n    if triggered:\n        logger.info(f\"\ud83c\udf89 TAKE PROFIT REACHED @ ${target_price:,.2f}\")\n    else:\n        logger.info(f\"\ud83c\udfaf Take Profit: ${target_price:,.2f} (Entry: ${entry_price:,.2f})\")\n    \n    block_outputs['block_1765395700238_48uktcjz387'] = result\n    return result\n\nasync def main():\n    \"\"\"Main automation loop.\"\"\"\n    logger.info(\"=\" * 50)\n    logger.info(\"Starting automation: A2\")\n    logger.info(\"=\" * 50)\n    \n    try:\n        \n        # Single-run automation\n        \n        await block_1765395591366_bho7jbq1ski_indicator(None)\n        \n        await block_1765395609515_lmc5ou41ysi_indicator(None)\n        \n        await block_1765395567293_5j7inrbqi2y_indicator(block_outputs.get('block-1765395591366-bho7jbq1ski'))\n        \n        # Source: Binance WebSocket\n        \n        # Note: block_1765395546076_nezgtx2m7qe_source() is an async generator\n        \n        # In continuous mode, it would be consumed in the loop\n        \n        source_data = await block_1765395546076_nezgtx2m7qe_source().__anext__() if hasattr(block_1765395546076_nezgtx2m7qe_source(), '__anext__') else await block_1765395546076_nezgtx2m7qe_source()\n        \n        await block_1765395762524_zapd3p6tsd9_entry(None)\n        \n        await block_1765395624818_u6jyp9qeif_stop_loss([block_outputs.get('block-1765395567293-5j7inrbqi2y'), block_outputs.get('block-1765395591366-bho7jbq1ski'), block_outputs.get('block-1765395609515-lmc5ou41ysi'), block_outputs.get('block-1765395762524-zapd3p6tsd9')])\n        \n        await block_1765395700238_48uktcjz387_take_profit([block_outputs.get('block-1765395567293-5j7inrbqi2y'), block_outputs.get('block-1765395591366-bho7jbq1ski'), block_outputs.get('block-1765395609515-lmc5ou41ysi'), block_outputs.get('block-1765395762524-zapd3p6tsd9')])\n        \n        \n        logger.info(\"\\n\" + \"=\" * 50)\n        logger.info(\"Automation completed successfully!\")\n        logger.info(\"=\" * 50)\n        \n        \n    except KeyboardInterrupt:\n        logger.info(\"\\nAutomation stopped by user\")\n    except Exception as e:\n        logger.error(f\"Automation error: {e}\")\n        raise\n\nif __name__ == \"__main__\":\n    asyncio.run(main())",
    "docker_image": null,
    "container_id": null,
    "process_id": null,
    "config": {},
    "paper_trading": true,
    "exchange": null,
    "symbols": [],
    "schedule_cron": null,
    "created_at": "2025-12-10T19:43:26.378503",
    "updated_at": "2025-12-12T21:23:37.837841",
    "last_run": null,
    "run_count": 0,
    "error_message": null,
    "total_pnl": 0.0,
    "win_rate": null,
    "total_trades": 0,
    "logs": [
      "[2025-12-12T21:23:37.838450] Started (PID: 1101209)",
      "[2025-12-12T21:23:38.260377] 15:23:38 | WARNING | pandas_ta not installed, some indicators may not work",
      "[2025-12-12T21:23:38.270978] 15:23:38 | INFO | ==================================================",
      "[2025-12-12T21:23:38.281403] 15:23:38 | INFO | Starting automation: A2",
      "[2025-12-12T21:23:38.291818] 15:23:38 | INFO | ==================================================",
      "[2025-12-12T21:23:38.302250] 15:23:38 | INFO | \ud83d\udcc8 Calculating MACD...",
      "[2025-12-12T21:23:38.312647] 15:23:38 | WARNING | Not enough data for MACD (need 35, have 1)",
      "[2025-12-12T21:23:38.322967] 15:23:38 | INFO | \ud83d\udcc8 Analyzing Market Structure...",
      "[2025-12-12T21:23:38.333304] 15:23:38 | INFO | \ud83d\udcc8 Calculating RSI...",
      "[2025-12-12T21:23:38.343555] 15:23:38 | WARNING | Not enough data for RSI (need 14, have 1)",
      "[2025-12-12T21:23:38.353808] 15:23:38 | INFO | \ud83d\udd0c Connecting to Binance WebSocket for BTCUSDT...",
      "[2025-12-12T21:23:39.065079] 15:23:39 | INFO | \u2713 Connected to Binance WebSocket"
    ]
  },
  {
    "id": "2ef6cbf5-1f30-49ac-aa51-1367493892cd",
    "name": "Final Verification",
    "description": "",
    "type": "scraper",
    "status": "draft",
    "deployment_type": "docker",
    "blocks": [
      {
        "id": "src",
        "type": "source",
        "name": "Test",
        "config": {},
        "position": {
          "x": 0.0,
          "y": 0.0
        },
        "connections": []
      }
    ],
    "generated_code": null,
    "docker_image": null,
    "container_id": null,
    "process_id": null,
    "config": {},
    "paper_trading": true,
    "exchange": null,
    "symbols": [],
    "schedule_cron": null,
    "created_at": "2025-12-12T23:14:03.426682",
    "updated_at": "2025-12-12T23:14:03.426684",
    "last_run": null,
    "run_count": 0,
    "error_message": null,
    "total_pnl": 0.0,
    "win_rate": null,
    "total_trades": 0,
    "logs": []
  },
  {
    "id": "6edf1d99-be9e-4b18-944d-60b972c58f28",
    "name": "BTC Sell Warning System",
    "description": "Multi-block automation to detect BTC sell signals using RSI, MACD and alert when conditions are met",
    "type": "trading_bot",
    "status": "draft",
    "deployment_type": "docker",
    "blocks": [
      {
        "id": "btc-source",
        "type": "source",
        "name": "Binance BTCUSDT WebSocket",
        "config": {
          "symbol": "BTCUSDT",
          "stream": "aggTrade"
        },
        "position": {
          "x": 100.0,
          "y": 200.0
        },
        "connections": [
          "rsi-1",
          "macd-1"
        ]
      },
      {
        "id": "rsi-1",
        "type": "indicator",
        "name": "RSI (Overbought=70)",
        "config": {
          "period": 14,
          "overbought": 70,
          "oversold": 30
        },
        "position": {
          "x": 350.0,
          "y": 100.0
        },
        "connections": [
          "fusion-1"
        ]
      },
      {
        "id": "macd-1",
        "type": "indicator",
        "name": "MACD Signal",
        "config": {
          "fast": 12,
          "slow": 26,
          "signal": 9
        },
        "position": {
          "x": 350.0,
          "y": 300.0
        },
        "connections": [
          "fusion-1"
        ]
      },
      {
        "id": "fusion-1",
        "type": "fusion",
        "name": "Confluence Scorer",
        "config": {
          "strategy": "weighted_average"
        },
        "position": {
          "x": 600.0,
          "y": 200.0
        },
        "connections": [
          "validator-1"
        ]
      },
      {
        "id": "validator-1",
        "type": "validator",
        "name": "Sell Signal Validator",
        "config": {
          "minConfidence": 0.6
        },
        "position": {
          "x": 850.0,
          "y": 200.0
        },
        "connections": [
          "alert-1"
        ]
      },
      {
        "id": "alert-1",
        "type": "notification",
        "name": "Discord Sell Alert",
        "config": {
          "webhookUrl": "https://discord.com/api/webhooks/your-webhook"
        },
        "position": {
          "x": 1100.0,
          "y": 200.0
        },
        "connections": []
      }
    ],
    "generated_code": null,
    "docker_image": null,
    "container_id": null,
    "process_id": null,
    "config": {},
    "paper_trading": true,
    "exchange": null,
    "symbols": [],
    "schedule_cron": null,
    "created_at": "2025-12-12T23:20:37.653809",
    "updated_at": "2025-12-12T23:20:37.653811",
    "last_run": null,
    "run_count": 0,
    "error_message": null,
    "total_pnl": 0.0,
    "win_rate": null,
    "total_trades": 0,
    "logs": []
  },
  {
    "id": "793e20d0-3259-4e49-bef0-f94ec679a203",
    "name": "BTC Sell Warning System",
    "description": "",
    "type": "trading_bot",
    "status": "stopped",
    "deployment_type": "docker",
    "blocks": [
      {
        "id": "btc-source",
        "type": "source",
        "name": "Binance BTCUSDT WebSocket",
        "config": {
          "symbol": "BTCUSDT",
          "stream": "aggTrade"
        },
        "position": {
          "x": 100.0,
          "y": 200.0
        },
        "connections": [
          "rsi-1",
          "macd-1"
        ]
      },
      {
        "id": "rsi-1",
        "type": "indicator",
        "name": "RSI (Overbought=70)",
        "config": {
          "period": 14,
          "overbought": 70,
          "oversold": 30
        },
        "position": {
          "x": 350.0,
          "y": 100.0
        },
        "connections": [
          "fusion-1"
        ]
      },
      {
        "id": "macd-1",
        "type": "indicator",
        "name": "MACD Signal",
        "config": {
          "fast": 12,
          "slow": 26,
          "signal": 9
        },
        "position": {
          "x": 350.0,
          "y": 300.0
        },
        "connections": [
          "fusion-1"
        ]
      },
      {
        "id": "fusion-1",
        "type": "fusion",
        "name": "Confluence Scorer",
        "config": {
          "strategy": "weighted_average"
        },
        "position": {
          "x": 600.0,
          "y": 200.0
        },
        "connections": [
          "validator-1"
        ]
      },
      {
        "id": "validator-1",
        "type": "validator",
        "name": "Sell Signal Validator",
        "config": {
          "minConfidence": 0.6
        },
        "position": {
          "x": 850.0,
          "y": 200.0
        },
        "connections": [
          "alert-1"
        ]
      },
      {
        "id": "alert-1",
        "type": "notification",
        "name": "Discord Sell Alert",
        "config": {
          "webhookUrl": "https://discord.com/api/webhooks/your-webhook"
        },
        "position": {
          "x": 1100.0,
          "y": 200.0
        },
        "connections": []
      }
    ],
    "generated_code": "#!/usr/bin/env python3\n\"\"\"\nAuto-generated automation script.\nAutomation: BTC Sell Warning System\nGenerated: 2025-12-12T17:41:33.822570\n\"\"\"\n\nimport asyncio\nimport json\nimport time\nimport logging\nfrom datetime import datetime\nfrom typing import Dict, List, Any, Optional\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s | %(levelname)s | %(message)s',\n    datefmt='%H:%M:%S'\n)\nlogger = logging.getLogger(__name__)\n\n\nimport websockets\n\n\nimport httpx\n\n\nimport pandas as pd\n\n\nimport numpy as np\n\n\ntry:\n    import pandas_ta as ta\nexcept ImportError:\n    logger.warning(\"pandas_ta not installed, some indicators may not work\")\n    ta = None\n\n\n# Output directory for this automation\nOUTPUT_DIR = Path(\"/home/kr/ChatOS-v2.1/sandbox-ui/data/automations/793e20d0-3259-4e49-bef0-f94ec679a203\")\nOUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n\n# Block state storage\nblock_outputs: Dict[str, Any] = {}\nblock_states: Dict[str, Dict] = {}\n\n\n@dataclass\nclass MarketData:\n    \"\"\"Market data from sources.\"\"\"\n    symbol: str\n    price: float\n    volume: float = 0.0\n    timestamp: float = field(default_factory=time.time)\n    bid: float = 0.0\n    ask: float = 0.0\n    extra: Dict = field(default_factory=dict)\n\n@dataclass\nclass Signal:\n    \"\"\"Trading signal from indicators/conditions.\"\"\"\n    name: str\n    value: Any\n    direction: str = \"neutral\"  # bullish, bearish, neutral\n    strength: float = 0.0  # 0.0 to 1.0\n    timestamp: float = field(default_factory=time.time)\n    metadata: Dict = field(default_factory=dict)\n\n@dataclass\nclass Order:\n    \"\"\"Order to be executed.\"\"\"\n    symbol: str\n    side: str  # buy, sell\n    order_type: str  # market, limit\n    quantity: float\n    price: Optional[float] = None\n    stop_loss: Optional[float] = None\n    take_profit: Optional[float] = None\n    metadata: Dict = field(default_factory=dict)\n\n@dataclass\nclass RiskCheck:\n    \"\"\"Result of risk validation.\"\"\"\n    approved: bool\n    reason: str = \"\"\n    adjusted_quantity: Optional[float] = None\n\n\n\ndef save_output(filename: str, data: Any):\n    \"\"\"Save data to output directory.\"\"\"\n    filepath = OUTPUT_DIR / filename\n    with open(filepath, 'w') as f:\n        if isinstance(data, (dict, list)):\n            json.dump(data, f, indent=2, default=str)\n        else:\n            f.write(str(data))\n    logger.info(f\"Saved output to {filepath}\")\n\ndef load_state(block_id: str) -> Dict:\n    \"\"\"Load persisted state for a block.\"\"\"\n    state_file = OUTPUT_DIR / f\".state_{block_id}.json\"\n    if state_file.exists():\n        with open(state_file) as f:\n            return json.load(f)\n    return {}\n\ndef save_state(block_id: str, state: Dict):\n    \"\"\"Persist state for a block.\"\"\"\n    state_file = OUTPUT_DIR / f\".state_{block_id}.json\"\n    with open(state_file, 'w') as f:\n        json.dump(state, f)\n\n\n\nasync def btc_source_source():\n    \"\"\"\n    Simulated Data Source: Binance BTCUSDT WebSocket\n    Symbol: BTCUSDT\n    \"\"\"\n    import random\n    \n    logger.info(\"\ud83c\udfb2 Generating simulated market data...\")\n    \n    base_price = 30000\n    volatility = 0.02\n    \n    # Generate random price movement\n    change = random.gauss(0, volatility)\n    price = base_price * (1 + change)\n    \n    market_data = MarketData(\n        symbol=\"BTCUSDT\",\n        price=price,\n        volume=random.uniform(100, 10000),\n        bid=price * 0.9999,\n        ask=price * 1.0001,\n    )\n    \n    block_outputs['btc_source'] = market_data\n    logger.info(f\"\ud83d\udcca Simulated BTCUSDT: ${market_data.price:,.2f}\")\n    \n    return market_data\n\nasync def rsi_1_indicator(input_data):\n    \"\"\"\n    RSI Indicator: RSI (Overbought=70)\n    Period: 14\n    Overbought: 70\n    Oversold: 30\n    \"\"\"\n    logger.info(\"\ud83d\udcc8 Calculating RSI...\")\n    \n    PERIOD = 14\n    OVERBOUGHT = 70\n    OVERSOLD = 30\n    \n    # Get price data\n    if isinstance(input_data, list):\n        prices = [d.price if hasattr(d, 'price') else d.get('close', d.get('price', 0)) for d in input_data]\n    elif hasattr(input_data, 'price'):\n        # Single data point - use stored history\n        state = block_states.get('rsi_1', {'prices': []})\n        state['prices'].append(input_data.price)\n        state['prices'] = state['prices'][-(PERIOD + 10):]  # Keep enough for calculation\n        block_states['rsi_1'] = state\n        prices = state['prices']\n    else:\n        prices = [input_data]\n    \n    if len(prices) < PERIOD:\n        logger.warning(f\"Not enough data for RSI (need {PERIOD}, have {len(prices)})\")\n        return Signal(name=\"RSI\", value=50, direction=\"neutral\", strength=0)\n    \n    # Calculate RSI\n    if ta is not None:\n        df = pd.DataFrame({'close': prices})\n        df['rsi'] = ta.rsi(df['close'], length=PERIOD)\n        rsi_value = df['rsi'].iloc[-1]\n    else:\n        # Manual RSI calculation\n        deltas = [prices[i] - prices[i-1] for i in range(1, len(prices))]\n        gains = [d if d > 0 else 0 for d in deltas[-PERIOD:]]\n        losses = [-d if d < 0 else 0 for d in deltas[-PERIOD:]]\n        avg_gain = sum(gains) / PERIOD\n        avg_loss = sum(losses) / PERIOD\n        rs = avg_gain / avg_loss if avg_loss != 0 else 100\n        rsi_value = 100 - (100 / (1 + rs))\n    \n    # Determine signal\n    if rsi_value >= OVERBOUGHT:\n        direction = \"bearish\"\n        strength = (rsi_value - OVERBOUGHT) / (100 - OVERBOUGHT)\n    elif rsi_value <= OVERSOLD:\n        direction = \"bullish\"\n        strength = (OVERSOLD - rsi_value) / OVERSOLD\n    else:\n        direction = \"neutral\"\n        strength = 0\n    \n    signal = Signal(\n        name=\"RSI\",\n        value=rsi_value,\n        direction=direction,\n        strength=min(1.0, strength),\n        metadata={'period': PERIOD}\n    )\n    \n    block_outputs['rsi_1'] = signal\n    logger.info(f\"\ud83d\udcca RSI({PERIOD}): {rsi_value:.2f} \u2192 {direction.upper()}\")\n    \n    return signal\n\nasync def macd_1_indicator(input_data):\n    \"\"\"\n    RSI Indicator: MACD Signal\n    Period: 14\n    Overbought: 70\n    Oversold: 30\n    \"\"\"\n    logger.info(\"\ud83d\udcc8 Calculating RSI...\")\n    \n    PERIOD = 14\n    OVERBOUGHT = 70\n    OVERSOLD = 30\n    \n    # Get price data\n    if isinstance(input_data, list):\n        prices = [d.price if hasattr(d, 'price') else d.get('close', d.get('price', 0)) for d in input_data]\n    elif hasattr(input_data, 'price'):\n        # Single data point - use stored history\n        state = block_states.get('macd_1', {'prices': []})\n        state['prices'].append(input_data.price)\n        state['prices'] = state['prices'][-(PERIOD + 10):]  # Keep enough for calculation\n        block_states['macd_1'] = state\n        prices = state['prices']\n    else:\n        prices = [input_data]\n    \n    if len(prices) < PERIOD:\n        logger.warning(f\"Not enough data for RSI (need {PERIOD}, have {len(prices)})\")\n        return Signal(name=\"RSI\", value=50, direction=\"neutral\", strength=0)\n    \n    # Calculate RSI\n    if ta is not None:\n        df = pd.DataFrame({'close': prices})\n        df['rsi'] = ta.rsi(df['close'], length=PERIOD)\n        rsi_value = df['rsi'].iloc[-1]\n    else:\n        # Manual RSI calculation\n        deltas = [prices[i] - prices[i-1] for i in range(1, len(prices))]\n        gains = [d if d > 0 else 0 for d in deltas[-PERIOD:]]\n        losses = [-d if d < 0 else 0 for d in deltas[-PERIOD:]]\n        avg_gain = sum(gains) / PERIOD\n        avg_loss = sum(losses) / PERIOD\n        rs = avg_gain / avg_loss if avg_loss != 0 else 100\n        rsi_value = 100 - (100 / (1 + rs))\n    \n    # Determine signal\n    if rsi_value >= OVERBOUGHT:\n        direction = \"bearish\"\n        strength = (rsi_value - OVERBOUGHT) / (100 - OVERBOUGHT)\n    elif rsi_value <= OVERSOLD:\n        direction = \"bullish\"\n        strength = (OVERSOLD - rsi_value) / OVERSOLD\n    else:\n        direction = \"neutral\"\n        strength = 0\n    \n    signal = Signal(\n        name=\"RSI\",\n        value=rsi_value,\n        direction=direction,\n        strength=min(1.0, strength),\n        metadata={'period': PERIOD}\n    )\n    \n    block_outputs['macd_1'] = signal\n    logger.info(f\"\ud83d\udcca RSI({PERIOD}): {rsi_value:.2f} \u2192 {direction.upper()}\")\n    \n    return signal\n\nasync def fusion_1_fusion(input_signals):\n    \"\"\"\n    Signal Fusion: Confluence Scorer\n    Model: \n    \"\"\"\n    logger.info(\"\ud83d\udd00 Fusing signals...\")\n    \n    # Collect all input signals\n    if not isinstance(input_signals, list):\n        input_signals = [input_signals]\n    \n    # Score fusion\n    bullish_score = 0\n    bearish_score = 0\n    total_weight = 0\n    \n    for sig in input_signals:\n        if hasattr(sig, 'direction'):\n            weight = sig.strength if hasattr(sig, 'strength') else 0.5\n            total_weight += weight\n            if sig.direction == \"bullish\":\n                bullish_score += weight\n            elif sig.direction == \"bearish\":\n                bearish_score += weight\n    \n    # Calculate fusion result\n    if total_weight > 0:\n        bullish_pct = bullish_score / total_weight\n        bearish_pct = bearish_score / total_weight\n        \n        if bullish_pct > 0.6:\n            direction = \"bullish\"\n            confidence = bullish_pct\n        elif bearish_pct > 0.6:\n            direction = \"bearish\"\n            confidence = bearish_pct\n        else:\n            direction = \"neutral\"\n            confidence = max(bullish_pct, bearish_pct)\n    else:\n        direction = \"neutral\"\n        confidence = 0\n    \n    result = Signal(\n        name=\"Fusion\",\n        value=confidence,\n        direction=direction,\n        strength=confidence,\n        metadata={\n            'bullish_score': bullish_score,\n            'bearish_score': bearish_score,\n            'input_count': len(input_signals),\n            'model': '',\n        }\n    )\n    \n    logger.info(f\"\ud83d\udd00 Fusion Result: {direction.upper()} (Confidence: {confidence:.2f})\")\n    \n    block_outputs['fusion_1'] = result\n    return result\n\nasync def validator_1_validate(input_signal):\n    \"\"\"\n    Signal Validator: Sell Signal Validator\n    Min Confidence: 0.6\n    \"\"\"\n    logger.info(\"\u2705 Validating signal...\")\n    \n    min_confidence = 0.6\n    \n    # Get signal confidence\n    confidence = 0\n    if hasattr(input_signal, 'strength'):\n        confidence = input_signal.strength\n    elif isinstance(input_signal, dict):\n        confidence = input_signal.get('confidence', input_signal.get('strength', 0))\n    \n    # Validate\n    valid = confidence >= min_confidence\n    \n    result = {\n        'valid': valid,\n        'confidence': confidence,\n        'threshold': min_confidence,\n        'signal': input_signal,\n    }\n    \n    if valid:\n        logger.info(f\"\u2705 Signal VALID: Confidence {confidence:.2f} >= {min_confidence}\")\n    else:\n        logger.info(f\"\u274c Signal INVALID: Confidence {confidence:.2f} < {min_confidence}\")\n    \n    block_outputs['validator_1'] = result\n    return result if valid else None\n\nasync def alert_1_notify(input_data):\n    \"\"\"\n    Console Notification: Discord Sell Alert\n    \"\"\"\n    message = None\n    \n    if isinstance(input_data, dict):\n        if input_data.get('triggered'):\n            message = input_data.get('reason', 'Alert triggered')\n        elif input_data.get('side'):\n            message = f\"Order: {input_data.get('side')} @ {input_data.get('fill_price', 'market')}\"\n    elif hasattr(input_data, 'direction'):\n        message = f\"Signal: {input_data.name} \u2192 {input_data.direction.upper()}\"\n    \n    if message:\n        logger.info(f\"\ud83d\udd14 ALERT: {message}\")\n        \n        # Also save to file\n        alert_log = OUTPUT_DIR / \"alerts.log\"\n        with open(alert_log, 'a') as f:\n            f.write(f\"{datetime.now().isoformat()} | {message}\\n\")\n    \n    block_outputs['alert_1'] = {'notified': message is not None, 'message': message}\n    return {'notified': message is not None, 'message': message}\n\nasync def main():\n    \"\"\"Main automation loop.\"\"\"\n    logger.info(\"=\" * 50)\n    logger.info(\"Starting automation: BTC Sell Warning System\")\n    logger.info(\"=\" * 50)\n    \n    try:\n        \n        # Single-run automation\n        \n        # Source: Binance BTCUSDT WebSocket\n        \n        # Note: btc_source_source() is an async generator\n        \n        # In continuous mode, it would be consumed in the loop\n        \n        source_data = await btc_source_source().__anext__() if hasattr(btc_source_source(), '__anext__') else await btc_source_source()\n        \n        await rsi_1_indicator(block_outputs.get('btc-source'))\n        \n        await macd_1_indicator(block_outputs.get('btc-source'))\n        \n        await fusion_1_fusion([block_outputs.get('rsi-1'), block_outputs.get('macd-1')])\n        \n        await validator_1_validate(block_outputs.get('fusion-1'))\n        \n        await alert_1_notify(block_outputs.get('validator-1'))\n        \n        \n        logger.info(\"\\n\" + \"=\" * 50)\n        logger.info(\"Automation completed successfully!\")\n        logger.info(\"=\" * 50)\n        \n        \n    except KeyboardInterrupt:\n        logger.info(\"\\nAutomation stopped by user\")\n    except Exception as e:\n        logger.error(f\"Automation error: {e}\")\n        raise\n\nif __name__ == \"__main__\":\n    asyncio.run(main())",
    "docker_image": null,
    "container_id": null,
    "process_id": null,
    "config": {},
    "paper_trading": true,
    "exchange": null,
    "symbols": [],
    "schedule_cron": null,
    "created_at": "2025-12-12T23:20:46.666316",
    "updated_at": "2025-12-12T23:41:33.827299",
    "last_run": null,
    "run_count": 0,
    "error_message": null,
    "total_pnl": 0.0,
    "win_rate": null,
    "total_trades": 0,
    "logs": [
      "[2025-12-12T23:33:07.655631] Started (PID: 1173695)",
      "[2025-12-12T23:33:07.884060] 17:33:07 | WARNING | pandas_ta not installed, some indicators may not work",
      "[2025-12-12T23:33:07.894673] 17:33:07 | INFO | ==================================================",
      "[2025-12-12T23:33:07.905169] 17:33:07 | INFO | Starting automation: BTC Sell Warning System",
      "[2025-12-12T23:33:07.915597] 17:33:07 | INFO | ==================================================",
      "[2025-12-12T23:33:07.926018] /tmp/chatos_automations/793e20d0-3259-4e49-bef0-f94ec679a203.py:425: RuntimeWarning: coroutine 'btc_source_source' was never awaited",
      "[2025-12-12T23:33:07.926322] source_data = await btc_source_source().__anext__() if hasattr(btc_source_source(), '__anext__') else await btc_source_source()",
      "[2025-12-12T23:33:07.926620] RuntimeWarning: Enable tracemalloc to get the object allocation traceback",
      "[2025-12-12T23:33:07.926821] 17:33:07 | INFO | \ud83c\udfb2 Generating simulated market data...",
      "[2025-12-12T23:33:07.926972] 17:33:07 | INFO | \ud83d\udcca Simulated BTCUSDT: $29,641.20",
      "[2025-12-12T23:33:07.927120] 17:33:07 | INFO | \ud83d\udcc8 Calculating RSI...",
      "[2025-12-12T23:33:07.927253] 17:33:07 | WARNING | Not enough data for RSI (need 14, have 1)",
      "[2025-12-12T23:33:07.927395] 17:33:07 | INFO | \ud83d\udcc8 Calculating RSI...",
      "[2025-12-12T23:33:07.927524] 17:33:07 | WARNING | Not enough data for RSI (need 14, have 1)",
      "[2025-12-12T23:33:07.927651] 17:33:07 | INFO | \ud83d\udd00 Fusing signals...",
      "[2025-12-12T23:33:07.927775] 17:33:07 | INFO | \ud83d\udd00 Fusion Result: NEUTRAL (Confidence: 0.00)",
      "[2025-12-12T23:33:07.927899] 17:33:07 | INFO | \u2705 Validating signal...",
      "[2025-12-12T23:33:07.928024] 17:33:07 | INFO | \u274c Signal INVALID: Confidence 0.00 < 0.6",
      "[2025-12-12T23:33:07.928148] 17:33:07 | INFO |",
      "[2025-12-12T23:33:07.928277] ==================================================",
      "[2025-12-12T23:33:07.928406] 17:33:07 | INFO | Automation completed successfully!",
      "[2025-12-12T23:33:07.928539] 17:33:07 | INFO | ==================================================",
      "[2025-12-12T23:33:07.928801] \u2713 Completed"
    ]
  }
]